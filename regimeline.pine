// ===== CHUNK 1 START =====

//@version=6
// Single source of truth for script title/version (used by strategy() + logs)
const string STRAT_TITLE = "MakeItHapen v7.03 — Strategy"

strategy(STRAT_TITLE,
     overlay=true,
     pyramiding=1,
     initial_capital=10000,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=4,
     commission_type=strategy.commission.percent,
     commission_value=0.1,
     slippage=2,
     calc_on_every_tick = true,
     process_orders_on_close = true,
     max_labels_count=500)

//====================================================
// Inputs
//====================================================
grpCore="Core"
emaFastLen  = input.int(21, "EMA Fast", group=grpCore, minval=1)
emaSlowLen  = input.int(55, "EMA Slow", group=grpCore, minval=1)
atrLen      = input.int(14, "ATR", group=grpCore, minval=1)
lvlLookback = input.int(24, "Decision Level Lookback", group=grpCore, minval=8)
bufATR      = input.float(0.10, "Decision buffer (ATR*x)", group=grpCore, step=0.05)


grpHTF="HTF Trend Veto"
htfTF      = input.timeframe("60", "HTF timeframe", group=grpHTF)
htfFastLen = input.int(21, "HTF EMA Fast", group=grpHTF, minval=1)
htfSlowLen = input.int(55, "HTF EMA Slow", group=grpHTF, minval=1)
htfNeutralSepPct = input.float(0.0050, "HTF neutral if EMA sep % <=", group=grpHTF, step=0.0001)


grpADX="ADX Filters"
adxLen       = input.int(14,  "ADX length", group=grpADX, minval=2)
adxSmooth    = input.int(14,  "ADX smoothing", group=grpADX, minval=1)
adxBullMin   = input.float(23, "Bull: require ADX >=", group=grpADX, step=0.5)
adxRangeAMax = input.float(22, "Range-A: require ADX <=", group=grpADX, step=0.5)
adxRangeASoftMax = input.float(36, "Range-A SOFT cap: allow up to ADX <=", group=grpADX, step=0.5)
adxBullExecMin = input.float(22, "Bull EXEC: require ADX >=", group=grpADX, step=0.5)
adxBullStartMin = input.float(20, "Bull START: require ADX >=", group=grpADX, step=0.5)
adxUseSlope  = input.bool(true, "Bull: require ADX rising (optional)", group=grpADX)
adxGateBullMode = input.bool(false, "ADX gate Bull MODE (router)", group=grpADX)
adxSlopeBars = input.int(3, "ADX rising over last N bars", group=grpADX, minval=1)
adxRAUseSoft    = input.bool(true, "Range-A: soft ADX (allow if ADX not rising)", group=grpADX)
adxRASlopeBars  = input.int(3, "Range-A: ADX slope bars", group=grpADX, minval=1)
adxBullAddMin = input.float(18, "Bull ADD: require ADX >=", group=grpADX, step=0.5)
adxBullAddSlopePad = input.float(4.0, "Bull ADD: slope required if ADX >= (AddMin + pad)", group=grpADX, step=0.5)
adxRARelaxIfFalling = input.bool(true, "Range-A: allow if ADX falling (recommended)", group=grpADX)

grpTune = "Tuning"
tunePreset = input.string("Balanced", "Preset", group=grpTune, options=["Balanced", "More Trades", "More Quality"])
minEntryScore = input.int(0, "Min entry score (0 disables)", group=grpTune, minval=0, maxval=5)

grpBull="Bull (Trend v1.2)"
bullPB_ATR        = input.float(0.30, "Retest zone above level (ATR*x)", group=grpBull, step=0.05)
bullPB_MaxDip_ATR = input.float(0.60, "Retest max dip below level (ATR*x)", group=grpBull, step=0.05)
bullLvlHold_ATR   = input.float(0.10, "Intrabar hold allowance under level (ATR*x)", group=grpBull, step=0.05)
bullHold_ATR      = input.float(0.10, "Hold buffer under retest low (ATR*x)", group=grpBull, step=0.05)
bullMinBodyPct    = input.float(0.20, "Reclaim candle body/range >=", group=grpBull, step=0.05)
bullBreakLookback = input.int(9, "Bull entry: reclaim must break last N-bar high", group=grpBull, minval=3)
bullArmMaxBars    = input.int(10, "Expire bull setup in N bars", group=grpBull, minval=3)
bullTS_Bars       = input.int(24, "Bull time-stop bars", group=grpBull, minval=5)
bullTS_MinMFE_ATR = input.float(0.30, "Time-stop only if MFE < ATR*x", group=grpBull, step=0.05)
bullInvNeed2Cl   = input.bool(true,  "Bull invalidation: require 2 closes below bullLevel", group=grpBull)
bullInvBuf_ATR   = input.float(0.10, "Bull invalidation buffer under bullLevel (ATR*x)",   group=grpBull, step=0.05)
bullTP1_ATR      = input.float(1.97, "Bull TP1 (ATR*x) — partial", group=grpBull, step=0.25)
bullTP1_Pct      = input.int(100, "Bull TP1 % to close", group=grpBull, minval=1, maxval=100)
bullTP0_ATR      = input.float(0.70, "Bull TP0 (ATR*x) — early partial", group=grpBull, step=0.05)
bullTP0_Pct      = input.int(60,  "Bull TP0 % to close", group=grpBull, minval=1, maxval=100)
bullUseDMI = input.bool(false, "Bull entry: require +DI > -DI", group=grpBull)
bullAcceptNeed2Cl      = input.bool(true,  "Bull accept-up requires 2 closes", group=grpBull)
bullPBRequireFromAbove = input.bool(true,  "Bull PB: require pullback from above zone", group=grpBull)
bullAddRequireTrailArmed = input.bool(false, "Bull ADD: require trail armed", group=grpBull)
bullStartMicroPB_ATR     = input.float(0.20, "Bull START: require micro pullback to EMAfast (ATR)", group=grpBull, step=0.05)
bullStartNoChaseMax_ATR  = input.float(0.80, "Bull START: max distance above bullLevel (ATR)",    group=grpBull, step=0.05)
bullNeedLocalTrend = input.bool(true, "Bull: require local EMA trend (fast>slow + rising)", group=grpBull)
bullEmaSlopeBars   = input.int(3, "Bull: EMA slope bars", group=grpBull, minval=1)

// --- PB guard (prevents late/chase PB entries) ---
bullPBMaxAbove_ATR      = input.float(0.80, "Bull PB: max close above bullLevel (ATR)", group=grpBull, step=0.05)
bullPBMaxBarsSinceAccept = input.int(24, "Bull PB: max bars since accept-up", group=grpBull, minval=1)
bullPBRequireTouchEF    = input.bool(false, "Bull PB: require pullback touch EMAfast or bullLevel", group=grpBull)
bullPBMaxExtAboveEma_ATR = input.float(1.20, "Bull PB: max extension above EMAfast (ATR) to allow PB", group=grpBull, step=0.05)
bullPBMinPullback_ATR    = input.float(0.60, "Bull PB: min pullback depth from trade high (ATR)", group=grpBull, step=0.05)
bullPBTouchRequireReclaim = input.bool(false, "Bull PB: require reclaim close after touch", group=grpBull)
bullPBMaxPerBull = input.int(2, "Bull PB: max PBs per bull leg", group=grpBull, minval=1, maxval=5)
bullPBLateStallAgeBars = input.int(72, "Bull PB: late-stall age (bars since START_BULL)", group=grpBull, minval=24, maxval=500)
bullPBLateStallNoHHBars = input.int(12, "Bull PB: late-stall bars no new high", group=grpBull, minval=4, maxval=200)
bullPBLateAgeBars        = input.int(72,  "Bull PB: late-lifecycle age (bars since START_BULL)", group=grpBull, minval=24, maxval=500)
bullPBLateMaxAbove_ATR   = input.float(1.05, "Bull PB: late veto if close above bullLevel > ATR", group=grpBull, step=0.05)
bullPBLateMinDepth_ATR   = input.float(1.05, "Bull PB: late veto if PB depth < ATR", group=grpBull, step=0.05)
bullPBMaxAgeBars = input.int(
    24,
    "Bull PB: max bars since START_BULL",
    group = grpBull,
    minval = 24,
    maxval = 500
)
pbTS_Bars = input.int(6, "Bull PB time-stop bars", group=grpBull, minval=1)
// --- PB stall-cluster scoring + veto (NEW) ---
bullPB_MinScore = input.int(1, "Bull PB: min score (stall score)", group=grpBull, minval=0, maxval=1)

bullPBStallLookback     = input.int(8,  "Bull PB: stall lookback bars",        group=grpBull, minval=3, maxval=20)
bullPBStallMinCount     = input.int(5,  "Bull PB: stall min bars (cluster)",   group=grpBull, minval=2, maxval=20)
bullPBStallBodyATR      = input.float(0.25, "Bull PB: stall body <= x * ATR",  group=grpBull, step=0.05, minval=0.05, maxval=1.0)
bullPBStallNeedHighFail = input.bool(true, "Bull PB: stall requires HH progress fail", group=grpBull)
// --- PB Failed-Continuation veto (NEW) ---
bullPBUseLateFail            = input.bool(true, "PB Failed-Continuation veto", group=grpBull)
bullPBLateFailMinImpAgeBars  = input.int(4, "Bull PB: late-fail min impulse-age bars", group=grpBull, minval=1, maxval=200)
bullPBLateFailMinStallCount  = input.int(3, "Bull PB: late-fail min stall bars (within lookback)", group=grpBull, minval=1, maxval=20)
// --- PB Freshness / Impulse-Age (NEW) ---
bullPBUseFreshness       = input.bool(true,  "PB Freshness veto (Impulse-Age)", group="Bull / PB", inline="PBF")
bullPBMaxImpulseAgeBars  = input.int(18,     "Max bars since last impulse",     group="Bull / PB", inline="PBF", minval=1)
bullPBFreshMinAgeBars    = input.int(24,     "Apply only if bull age >= bars",  group="Bull / PB", minval=0)
// ---- PB Expansion-Age (NEW axis) ----
bullPBUseExpAge          = input.bool(true,  "PB use Expansion-Age veto", group=grpBull)
bullPBMaxExpAgeBars      = input.int(18,     "PB max bars since last expansion", group=grpBull, minval=1)

// --- PB Late-ExpAge + Weak Candle veto (Candidate) ---
// VETO if bullPBExpAgeBars >= N AND bodyPct <= X
bullPBUseLateExpAgeBodyVeto = input.bool(true, "PB veto: late ExpAge + weak candle", group=grpBull)
bullPBLateExpAgeBars_VetoN   = input.int(60, "PB veto: ExpAge bars >=", group=grpBull, minval=1, maxval=500)
bullPBLateBodyPct_VetoMax    = input.float(0.70, "PB veto: bodyPct <=", group=grpBull, step=0.05, minval=0.0, maxval=1.0)

// --- Bull Acceptance-Compression entry (no PB) ---
bullCompOn = input.bool(true, "Bull COMP: enable acceptance-compression entry", group=grpBull)
bullCompMaxBodyPct = input.float(0.45, "Bull COMP: max body/range (compression)", group=grpBull, step=0.05)
bullCompCloseNearHighMin = input.float(0.60, "Bull COMP: close in top X of range", group=grpBull, step=0.05)
bullCompHold_ATR = input.float(0.10, "Bull COMP: low must hold bullLevel - ATR*x", group=grpBull, step=0.05)
bullCompMaxExt_ATR = input.float(0.60, "Bull COMP: max extension above bullLevel (ATR)", group=grpBull, step=0.05)

bullTrailOn      = input.bool(true, "Bull runner: trail ON", group=grpBull)
bullTrailUseSlow = input.bool(true, "Bull runner: trail EMA Slow (else EMA Fast)", group=grpBull)
bullTrailBuf_ATR = input.float(0.10, "Bull runner: buffer under EMA (ATR*x)", group=grpBull, step=0.05)
bullTrailArm_ATR = input.float(0.80, "Bull runner: arm trail only after MFE >= ATR*x", group=grpBull, step=0.05)
// --- Bull MOM_LOSS gating (Option B) ---
bullMomLossOn              = input.bool(true,  "Bull MOM_LOSS: enable", group=grpBull)
bullMomLossGateWeak        = input.bool(true,  "Bull MOM_LOSS: gate by weak context (Option B)", group=grpBull)
bullMomLossAllowHTFOff     = input.bool(true,  "MOM_LOSS allowed when HTF OFF", group=grpBull)
bullMomLossAllowHTFNeutral = input.bool(true,  "MOM_LOSS allowed when HTF neutral", group=grpBull)
bullMomLossAllowHTFFlipOff = input.bool(true,  "MOM_LOSS allowed on HTF_OFF flip bar", group=grpBull)
bullMomLossAllowAfterEndBull = input.bool(true, "MOM_LOSS allowed after END_BULL (in-trade)", group=grpBull)
bullMomLossAllowAfterTP1Roll = input.bool(true, "MOM_LOSS allowed after TP1 on first rollover (close<EMAfast)", group=grpBull)
// --- MOM_LOSS tuning: earlier trigger AFTER TP1 + END_BULL only ---
bullMomBarsAfterEndBull   = input.int(4,   "MOM_LOSS stall bars after END_BULL (TP1)", group=grpBull, minval=1)
bullMomEmaClosesAfterEnd  = input.int(1,   "MOM_LOSS EMA closes after END_BULL (TP1)", group=grpBull, minval=1, maxval=2)
bullMomGivebackATR_AfterEnd = input.float(0.35, "MOM_LOSS giveback ATR after END_BULL (TP1)", group=grpBull, step=0.05)
bullMomMaxBarsAfterTP1    = input.int(14,  "MOM_LOSS only within N bars after TP1", group=grpBull, minval=1)
bullAddOn           = input.bool(true,  "Bull ADD: enable continuation add-entry", group=grpBull)
bullAddSpacingBars  = input.int(18,     "Bull ADD: min bars between adds", group=grpBull, minval=1)
bullAddMaxExt_ATR   = input.float(1.40, "Bull ADD: block if extended > ATR*x above EMAfast", group=grpBull, step=0.05)
bullAddDip_ATR      = input.float(0.25, "Bull ADD: pullback dip under EMAfast <= ATR*x", group=grpBull, step=0.05)
bullAddBreakLB      = input.int(6,      "Bull ADD: reclaim breaks last N-bar high", group=grpBull, minval=3)
bullAddBodyPct      = input.float(0.18, "Bull ADD: body/range >=", group=grpBull, step=0.02)
bullAddAfterTP1Only = input.bool(true, "Bull ADD: allow only after TP1", group=grpBull)
bullAddProofMFE_ATR = input.float(0.80, "Bull ADD: allow after MFE >= ATR*x (proof)", group=grpBull, step=0.05)
bullStartEntryOn = input.bool(false, "Bull: allow START entry (breakout follow-through)", group=grpBull)
bullStartRequireMicroPB = input.bool(false, "Bull START: require microPB touch (looser=earlier entry)", group=grpBull)
bullStartEntryMaxExt  = input.float(1.05, "Bull START: max extension (ATR)", step=0.05)   // keep tight
bullStartEntryMaxExtEMA = input.float(1.60, "Bull START: max extension above EMAfast (ATR)", step=0.05, group=grpBull)
bullStartEntryBodyPct = input.float(0.22, "Bull START: min body %", step=0.01)            // 0.20–0.25 typical
bullStartWindowBars   = input.int(1, "Bull START: allow within N bars after accept-up", minval=1, maxval=6, group=grpBull)
bullPB_ExecADXMin = input.float(18, "Bull PB EXEC: require ADX >=", group=grpADX, step=0.5)
bullAddCloseNearHigh = input.float(0.70, "Bull ADD: close in top X of range", group=grpBull, step=0.05)


// Conditional invalidation (tight early, looser after TP1)
bullInvAfterTP1Need2Cl = input.bool(true,  "Bull invalidation AFTER TP1: require 2 closes", group=grpBull)
bullInvAfterTP1Buf_ATR = input.float(0.10, "Bull invalidation AFTER TP1: buffer (ATR*x)", group=grpBull, step=0.05)

grpRA="Range-A (Balanced v1.1-A)"
raBalMaxWidth_ATR  = input.float(3.00, "Balance max width (ATR*x)", group=grpRA, step=0.25)
raBalMaxEMASep_ATR = input.float(0.60, "Balance max EMA separation (ATR*x)", group=grpRA, step=0.05)
raDisc_ATR         = input.float(0.35, "Discount below rollLow (ATR*x)", group=grpRA, step=0.05)
raDiscLookback     = input.int(12, "Discount must occur within N bars", group=grpRA, minval=1)
raModeGraceBars = input.int(6, "Range-A mode grace bars after discount (when balance breaks)", group=grpRA, minval=0)
raStop_ATR         = input.float(0.45, "Stop buffer (ATR*x)", group=grpRA, step=0.05)
raMaxEntryAboveLow_ATR = input.float(1.15, "RA: entry must be <= DL_low + ATR*x", group=grpRA, step=0.05)
raUseNearLow = input.bool(true, "RA: enforce near-low entry (hard veto)", group=grpRA)
raRequireBelowMid = input.bool(true, "RA: require entry below snapshot MID (avoid negative RR)", group=grpRA)
raMaxRisk_ATR  = input.float(2.30, "RA: max allowed risk (ATR)", group=grpRA, step=0.05)
raRiskFallbackToDL = input.bool(true, "RA: if StructLow risk too big, gate risk using DL_low stopbase", group=grpRA)
raStructStopMaxGap_ATR = input.float(0.80, "RA: if StructLow is > ATR*x below DL_low, use DL_low stopbase", group=grpRA, step=0.05)
raMinRR_ToMid  = input.float(0.45, "RA: min RR to Mid", group=grpRA, step=0.05)
raMinRR_Hard = input.float(0.20, "RA: min RR HARD floor (execution)", group=grpRA, step=0.05)
raUseRRGate = input.bool(true, "RA: enforce RR-to-mid (hard veto)", group=grpRA)
raStopNeed2Cl      = input.bool(true, "RA stop requires 2 closes below", group=grpRA)
raExecNeed2Cl = input.bool(false, "RA EXEC: require 2 closes above DL_low (else 1-close reclaim)", group=grpRA)
raTS_Bars          = input.int(1, "RA time-stop bars", group=grpRA, minval=1)
raAllowHTFNeutral = input.bool(false, "Range-A allowed on HTF neutral", group=grpRA)
raUseRetestEntry   = input.bool(true,  "RA Entry: require retest-hold")
raRetestBuf_ATR    = input.float(0.10, "RA Retest touch buffer (ATR)", step=0.05)
raRetestNeedGreen  = input.bool(true,  "RA Retest bar must be green")

grpRAFilters="Range-A vetoes"
raUseRSI    = input.bool(true, "RSI veto ON", group=grpRAFilters)
raRsiLen    = input.int(14, "RSI len", group=grpRAFilters, minval=2)
raRsiMax    = input.float(55, "Allow entry only if RSI <=", group=grpRAFilters, step=0.5)
raRsiWashoutBypass = input.bool(true, "RA: bypass RSI veto on washout reclaim (recommended)", group=grpRAFilters)
raNeedSweep = input.bool(true, "Require sweep/fresh-low structure", group=grpRAFilters)
sweepLen    = input.int(10, "Sweep lookback", group=grpRAFilters, minval=3)
raWasBelowLookback = input.int(8, "RA reclaim proof: was below low within N bars", group=grpRAFilters, minval=2, maxval=30)

grpRB="Range-B (Re-Anchor v1.1-B)"
rbConfirmBars      = input.int(10, "New balance confirm bars", group=grpRB, minval=5)
rbBalMaxWidth_ATR  = input.float(2.50, "New balance max width (ATR*x)", group=grpRB, step=0.25)
rbBalMaxEMASep_ATR = input.float(0.70, "New balance max EMA separation (ATR*x)", group=grpRB, step=0.05)
rbTS_Bars          = input.int(36, "RB time-stop bars (highest priority)", group=grpRB, minval=5)
rbTarget_ATR       = input.float(0.75, "RB Target1 (ATR*x)", group=grpRB, step=0.25)

// --- Range-B SHORT execution (Commit S2) ---
rbShortOn          = input.bool(false, "Range-B: enable SHORT entries (down re-anchor)", group=grpRB)
rbShortADXMin      = input.float(18, "RB SHORT: require ADX >=", group=grpRB, step=0.5)
rbShortUseSlope    = input.bool(true, "RB SHORT: require ADX rising", group=grpRB)
rbShortSlopeBars   = input.int(3, "RB SHORT: ADX rising over N bars", group=grpRB, minval=1)
rbShortCloseNearLo = input.float(0.35, "RB SHORT: close must be in bottom X of range", group=grpRB, step=0.05)
rbS_PB_MaxPop_ATR  = input.float(0.60, "RB SHORT: retest max pop above RB value (ATR*x)", group=grpRB, step=0.05)
rbS_Hold_ATR       = input.float(0.10, "RB SHORT: close hold allowance above value (ATR*x)", group=grpRB, step=0.05)
rbS_MinBodyPct     = input.float(0.20, "RB SHORT: rejection candle body/range >=", group=grpRB, step=0.05)
rbS_BreakLookback  = input.int(9, "RB SHORT: rejection must break last N-bar low", group=grpRB, minval=3)
rbS_ArmMaxBars     = input.int(10, "RB SHORT: expire retest in N bars", group=grpRB, minval=3)
rbS_TS_Bars        = input.int(24, "RB SHORT time-stop bars", group=grpRB, minval=5)
rbS_TS_MinMFE_ATR  = input.float(0.30, "RB SHORT TS only if MFE < ATR*x", group=grpRB, step=0.05)
rbS_InvNeed2Cl     = input.bool(true, "RB SHORT invalidation: require 2 closes above value", group=grpRB)
rbS_InvBuf_ATR     = input.float(0.10, "RB SHORT invalidation buffer (ATR*x)", group=grpRB, step=0.05)

grpBear="Bear (Acceptance-down v1.3)"
bearBuf_ATR      = input.float(0.45, "Break/accept buffer (ATR*x)", group=grpBear, step=0.05)
bearNeed2Cl      = input.bool(true, "Accept-down requires 2 closes", group=grpBear)
bearEarly_On     = input.bool(true,  "Early entry on 1st close below break (pre-accept)", group=grpBear)
bearEarly_QtyPct = input.int(100, "Early entry qty % (if pyramiding=0 keep 100)", minval=1, maxval=100, group=grpBear)

bearLockoutBars  = input.int(6, "Bear lockout bars after accept (flat)", group=grpBear, minval=0)
bearKillUseHTFveto = input.bool(true, "Bear kill-switch requires HTF OFF (v2.7 default)", group=grpBear)
bearMaxBars      = input.int(480, "Bear expires if not renewed within N bars", group=grpBear, minval=0)
bearRenewTighten = input.bool(true, "On renewal, tighten break/reclaim snapshot to latest", group=grpBear)
shortCooldownAfterHTFBullBars = input.int(48, "SHORT cooldown after HTF bull (bars)", group=grpBear, minval=0)
bearNeedLocalDowntrend = input.bool(true, "Bear SHORT: require local EMA downtrend (fast<slow + falling)", group=grpBear)
bearEmaSlopeBars       = input.int(3, "Bear SHORT: EMA slope bars", group=grpBear, minval=1)

// --- Bear SHORT execution (Commit S1) ---
bearShortOn        = input.bool(true, "Bear: enable SHORT entries (v1.3 only)", group=grpBear)
bearShortADXMin      = input.float(18, "Bear SHORT: require ADX >=", group=grpBear, step=0.5)
bearShortUseSlope    = input.bool(true, "Bear SHORT: require ADX rising", group=grpBear)
bearShortSlopeBars   = input.int(3, "Bear SHORT: ADX rising over N bars", group=grpBear, minval=1)
bearShortCloseNearLo = input.float(0.35, "Bear SHORT: close must be in bottom X of range", group=grpBear, step=0.05)
bearAcceptEntryOn = input.bool(true, "Bear: allow entry on acceptance-down (no retest)", group=grpBear)
bearExitUseReclaim = input.bool(true,  "Bear short: exit on LTF reclaim (pre HTF-BULL-KILL)", group=grpBear)
bearExitReclaimBars = input.int(2,     "Bear short: reclaim closes needed",                  group=grpBear, minval=1)
bearExitUseEmaReclaim = input.bool(true, "Bear short: EMAfast reclaim counts as reclaim",    group=grpBear)

bearPB_MaxPop_ATR  = input.float(0.60, "Bear SHORT: retest max pop above bearBreakLvl (ATR*x)", group=grpBear, step=0.05)
bearLvlHold_ATR    = input.float(0.10, "Bear SHORT: close hold allowance above bearBreakLvl (ATR*x)", group=grpBear, step=0.05)

bearMinBodyPct     = input.float(0.20, "Bear SHORT: breakdown candle body/range >=", group=grpBear, step=0.05)
bearBreakLookback  = input.int(9, "Bear SHORT: breakdown must break last N-bar low", group=grpBear, minval=3)

bearArmMaxBars     = input.int(14, "Bear SHORT: expire retest in N bars", group=grpBear, minval=3)
bearTS_Bars        = input.int(24, "Bear SHORT time-stop bars", group=grpBear, minval=5)
bearTS_MinMFE_ATR  = input.float(0.30, "Bear TS only if MFE < ATR*x", group=grpBear, step=0.05)

// --- Bear SHORT: TP1 + post-TP1 protection (runner-safe) ---
bearTP1_ATR       = input.float(1.65, "Bear TP1 (ATR*x) — partial", group=grpBear, step=0.25)
bearTP1_R         = input.float(0.8, "Bear TP1 (R) — partial (uses stop distance)", group=grpBear, step=0.05, minval=0.10, maxval=5.00)
bearTP1_Pct       = input.int(33, "Bear TP1 % to close", group=grpBear, minval=1, maxval=100)
bearTP0_ATR       = input.float(0.70, "Bear TP0 (ATR*x) — early partial", group=grpBear, step=0.05)
bearTP0_Pct       = input.int(60, "Bear TP0 % to close", group=grpBear, minval=1, maxval=100)
bearProt0Buf_ATR  = input.float(0.05, "Bear post-TP0 protect: stop above entry (ATR*x)", group=grpBear, step=0.05)
bearProt0Need2Cl  = input.bool(false, "Bear post-TP0 protect: require 2 closes", group=grpBear)
bearProtBuf_ATR   = input.float(0.10, "Bear post-TP1 protect: stop above entry (ATR*x)", group=grpBear, step=0.05)
bearProtNeed2Cl   = input.bool(true, "Bear post-TP1 protect: require 2 closes", group=grpBear)
bearTrailOn       = input.bool(true,  "Bear post-TP1: enable EMA trail (runner)", group=grpBear)
bearTrailBuf_ATR  = input.float(0.25, "Bear post-TP1: EMA trail buffer (ATR*x)",  group=grpBear, step=0.05)

bearInvNeed2Cl     = input.bool(true, "Bear SHORT invalidation: require 2 closes above bearReclLvl", group=grpBear)
bearAdxMin        = input.float(20, "Bear SHORT: require ADX >=", group=grpBear, step=0.5)
bearPB_CloseUnder_ATR = input.float(0.05, "Bear SHORT: retest close must be UNDER breakLvl by ATR*x", group=grpBear, step=0.01)

rbUseSnapshotAccept = input.bool(true, "RB attempt acceptance uses snapshot (strict)", group=grpRB)

grpTS="Time-stop downgrades"
downgradeBars = input.int(10, "Downgrade hold bars (after time-stop)", group=grpTS, minval=0)

grpVis="Visual"
showModeBg     = input.bool(true, "Background by mode", group=grpVis)
showRegimeBg   = input.bool(true, "Background by regime (full chart)", group=grpVis)
regimeBgAlpha  = input.int(90, "Regime BG opacity (0=solid,100=none)", group=grpVis, minval=0, maxval=100)
regimeUseRaw   = input.bool(true, "Use RAW regime states (not router mode)", group=grpVis)
showExecMarks  = input.bool(true, "Show EXEC markers", group=grpVis)
showDebugPlots = input.bool(true, "Show DEBUG plots", group=grpVis)
showLogTable   = input.bool(false, "Show trade log table", group=grpVis)

grpObs="Observability"
showModeLabel   = input.bool(true, "Show mode label (last bar)", group=grpObs)
showRegimeMarks = input.bool(true, "Show Range-A / Range-B regime markers", group=grpObs)
showRegimeFlipLabels = input.bool(true, "Show regime START/END labels", group=grpObs)
regimeLabelOnlyOnClose = input.bool(true, "Regime labels only on confirmed bars", group=grpObs)
regimeMinBars = input.int(2, "Min bars to confirm new regime before labeling", group=grpObs, minval=1, maxval=10)
bullStartStyle = input.string("UP",  "Bull START label style", group=grpObs, options=["UP","LEFT"])
bullEndStyle   = input.string("LEFT","Bull END label style",   group=grpObs, options=["LEFT","DOWN"])

//====================================================
// Logs (Layer 1 export)
//====================================================
grpLogs="Logs"
exportToLogs = input.bool(false, "Export to Logs", group=grpLogs)

grpLog = "Logging"
logTZ = input.string("Europe/Sofia", "Log timezone", group=grpLog)


//====================================================
// Logs (Layer 2 export: window around events)
//====================================================
exportL2 = input.bool(false, "Export L2 Window Logs", group=grpLogs)
l2WindowBars = input.int(20, "L2 window bars (±)", group=grpLogs, minval=1, maxval=200)
l2OverlapN   = input.int(8,  "L2 overlap N", group=grpLogs, minval=2, maxval=50)
l2RangeN     = input.int(20, "L2 range width N", group=grpLogs, minval=5, maxval=200)
l2VolN       = input.int(20, "L2 volatility baseline N", group=grpLogs, minval=5, maxval=200)




grpDiag="Diagnostics"
showDiagHUD = input.bool(true, "Show ADX Diagnostics HUD", group=grpDiag)
showBlockLabels = input.bool(false, "Show labels ONLY when entry is blocked", group=grpDiag)
dbgPBProbe = input.bool(false, "DBG: PBDBG to Logs (PB candidates)", group=grpDiag)
dbgPBProbeIncludeBlocked = input.bool(true, "DBG: PBDBG include BLOCKED candidates", group=grpDiag)


//====================================================
// Precompute
//====================================================
emaFast = ta.ema(close, emaFastLen)
emaSlow = ta.ema(close, emaSlowLen)
atr     = ta.atr(atrLen)
lblPadUp   = atr * 0.05   // used for labels above candles (high + pad)
lblPadDown = atr * 0.05   // used for labels below candles (low - pad)

// --- Multi-bar change helper (Pine-safe) ---
chgN(_src, _n) =>
    // Returns _src - _src[_n], guarded for early bars
    na(_src[_n]) ? na : (_src - _src[_n])


// --- EMA slope precomputes (always execute; avoids conditional ta.change warnings)
emaFastSlopeBull = chgN(emaFast, bullEmaSlopeBars)
emaFastSlopeBear = chgN(emaFast, bearEmaSlopeBars)

bullLocalTrendOk =
     (not bullNeedLocalTrend) or
     ((emaFast > emaSlow) and (emaFastSlopeBull > 0))

bearLocalDowntrendOk =
     (not bearNeedLocalDowntrend) or
     ((emaFast < emaSlow) and (emaFastSlopeBear < 0))


rollHigh = ta.highest(high[1], lvlLookback)
rollLow  = ta.lowest(low[1],  lvlLookback)
rollMid  = (rollHigh + rollLow) * 0.5
decHigh = rollHigh + atr * bufATR
decLow  = rollLow  - atr * bufATR


rng     = math.max(high - low, syminfo.mintick)
bodyPct = math.abs(close - open) / rng

var bool raDiscRecent = false


// HTF veto
htfEmaFast = request.security(syminfo.tickerid, htfTF, ta.ema(close, htfFastLen))
htfEmaSlow = request.security(syminfo.tickerid, htfTF, ta.ema(close, htfSlowLen))
htfClose   = request.security(syminfo.tickerid, htfTF, close)
htfTrendOk = htfEmaFast > htfEmaSlow
htfSepPct  = math.abs(htfEmaFast - htfEmaSlow) / htfClose
htfNeutral = htfSepPct <= htfNeutralSepPct
var int lastHTFBullBar = na
if barstate.isconfirmed and htfTrendOk and (not htfNeutral)
    lastHTFBullBar := bar_index

shortCooldownOk = (shortCooldownAfterHTFBullBars <= 0) or na(lastHTFBullBar) or ((bar_index - lastHTFBullBar) > shortCooldownAfterHTFBullBars)

htfOffForRA = (not htfTrendOk) or (raAllowHTFNeutral and htfNeutral)
// Bull is allowed on HTF-neutral ONLY if Range-A context is NOT active.
// This prevents Bull from stealing RA during neutral, but avoids "dead" neutral periods.
htfBullOk = htfTrendOk and (not htfNeutral or not (raAllowHTFNeutral and raDiscRecent))
//====================================================
// HTF state + HTF flip event (for logs)
//====================================================
htfOnNow = htfTrendOk and (not htfNeutral)   // strict HTF_ON (neutral treated as OFF)
var bool   htfOnPrev = false
var bool   htfOnPrevInit = false
var string htfFlipEventNow = "NONE"          // "HTF_ON","HTF_OFF","NONE"
var int    htfFlipBar = na

if barstate.isconfirmed
    if not htfOnPrevInit
        htfOnPrev := htfOnNow
        htfOnPrevInit := true
        htfFlipEventNow := "NONE"
    else
        if htfOnNow != htfOnPrev
            htfFlipEventNow := htfOnNow ? "HTF_ON" : "HTF_OFF"
            htfFlipBar := bar_index
            htfOnPrev := htfOnNow
        else
            htfFlipEventNow := "NONE"

var float bullLevel = na

//====================================================
// Bull flip type (START_BULL / END_BULL / NONE) + acceptUp streak
//====================================================
var string lastBullFlipType = "NONE"   // "START_BULL","END_BULL","NONE"
var int    bullAcceptUpCnt  = 0        // consecutive closes > bullLevel (streak)

if barstate.isconfirmed
    bullAcceptUpCnt := (not na(bullLevel) and close > bullLevel) ? (nz(bullAcceptUpCnt[1]) + 1) : 0

//====================================================
// Tuning presets (small deltas, big impact)
//====================================================
float dBullBody = 0.0
int   dBullBreakLB = 0
float dAdxExec = 0.0
float dRaRsi = 0.0

bool  tuneRelaxSweep = false
bool  tuneRelaxBelowMid = false

if tunePreset == "More Trades"
    dBullBody     := -0.04          // easier reclaim candle
    dBullBreakLB  := -2             // breaks shorter micro-structure
    dAdxExec      := -2.0           // exec ADX slightly easier
    dRaRsi        := +5.0           // RSI veto less restrictive
    tuneRelaxSweep := true          // allow RA without sweep requirement
    tuneRelaxBelowMid := true       // don't force below-mid (reduces missed reclaims)
else if tunePreset == "More Quality"
    dBullBody     := +0.03
    dBullBreakLB  := +1
    dAdxExec      := +2.0
    dRaRsi        := -3.0
    tuneRelaxSweep := false
    tuneRelaxBelowMid := false

// Apply tuned values (clamp where needed)
bullMinBodyPct_T = math.max(0.05, bullMinBodyPct + dBullBody)
bullBreakLookback_T = math.max(3, bullBreakLookback + dBullBreakLB)

adxBullExecMin_T  = math.max(5.0, adxBullExecMin + dAdxExec)
adxBullPBExecMin_T = math.max(5.0, bullPB_ExecADXMin + dAdxExec)

raRsiMax_T = raRsiMax + dRaRsi

[pdi, mdi, adx] = ta.dmi(adxLen, adxSmooth)

// Precompute (Pine consistency): history funcs must run each calculation
float adxSlopeNow = chgN(adx, adxSlopeBars)

// --- ADX split: Regime vs Execution ---
// Regime qualification (STRICT): ADX >= min, optional rising filter
adxRising        = adxSlopeNow > 0
adxBullRegimeOk  = (adx >= adxBullMin) and (not adxUseSlope or adxRising)

// Execution inside Bull (SOFT): ADX >= adxBullExecMin, no slope requirement
adxBullExecOk = (adx >= adxBullExecMin_T)
adxBullPBExecOk = (adx >= adxBullPBExecMin_T)
adxBullAddOk = (adx >= adxBullAddMin)
// ADD slope required only when ADX is already elevated (coin-agnostic compromise)
adxBullAddSlopeRequired = adx >= (adxBullAddMin + adxBullAddSlopePad)

// Range-A quality: non-trending / compressive
adxRASurge = chgN(adx, adxRASlopeBars) > 3.0
adxRAFallOk = chgN(adx, adxRASlopeBars) < 0

adxRAOk =
     (adx <= adxRangeAMax) or
     (adxRAUseSoft and (adx <= adxRangeASoftMax) and (not adxRASurge)) or
     (adxRARelaxIfFalling and (adx <= adxRangeASoftMax) and adxRAFallOk)

// --- Short quality gates (chop filter) ---
adxRisingBearS = chgN(adx, bearShortSlopeBars) > 0
bearShortADXOk = (adx >= bearShortADXMin) and (not bearShortUseSlope or adxRisingBearS)

adxRisingRBS = chgN(adx, rbShortSlopeBars) > 0
rbShortADXOk = (adx >= rbShortADXMin) and (not rbShortUseSlope or adxRisingRBS)

// Candle close-location (0 = at low, 1 = at high)
closeLoc = (rng > 0) ? ((close - low) / rng) : 0.5
bearCloseNearLowOk = closeLoc <= bearShortCloseNearLo
rbCloseNearLowOk   = closeLoc <= rbShortCloseNearLo



inPos   = strategy.position_size != 0
isLong  = strategy.position_size > 0
isShort = strategy.position_size < 0

//====================================================
// Mode enum + helpers
//====================================================
enum Mode
    Bull
    RangeA
    RangeB
    Wait

modeToStr(m) =>
    string s = "WAIT"
    if m == Mode.Bull
        s := "BULL"
    else if m == Mode.RangeA
        s := "RANGE-A"
    else if m == Mode.RangeB
        s := "RANGE-B"
    s

lblStyle(_s) => _s == "UP" ? label.style_label_up : _s == "DOWN" ? label.style_label_down : label.style_label_left




//====================================================
// Persistent state (router + engines)
//====================================================

// Position origin tag
var string posTag = ""   // "", "BULL", "RANGEA", "RANGEB"

// Persistent entry-origin label used for exit logging (Strategy v1.0 requirement)
var string entryModeTag = ""  // "", "BULL", "RANGE-A", "RANGE-B"

// --- Entry reason tagging (debug-safe, affects only comments) ---
var string lastEntryReason = ""


// Map posTag storage format to log format
posTagToLogMode(_tag) =>
    string m = ""
    if _tag == "BULL"
        m := "BULL"
    else if _tag == "RANGEA"
        m := "RANGE-A"
    else if _tag == "RANGEB"
        m := "RANGE-B"
    else if _tag == "BEAR"
        m := "BEAR"
    m


logModeNow() =>
    entryModeTag != "" ? entryModeTag : posTagToLogMode(posTag)

//====================================================
// L2 feature state (bars-since trackers)
//====================================================
var int l2_lastImpulseBar = na
var int l2_lastAcceptBar  = na
var int l2_lastReclaimBar = na


// ---- Forced mode after time-stop downgrade (router override while flat)
var Mode forcedMode = Mode.Wait
var int  forcedUntilBar = na
forcedActive = (not inPos) and (not na(forcedUntilBar)) and (bar_index <= forcedUntilBar)

// ---- Bear acceptance-down (flat-only regime, kill-switch exits)
var bool  pendingBear     = false
var bool  bearActive      = false
var float bearBreakLvl    = na
var float bearReclLvl     = na
var int   bearAcceptedBar = na
var int   bearRenewBar    = na
var int   bearStartBar = na
var float bearStartY   = na
var int   bearEndBar   = na
var float bearEndY     = na

// ---- Bear SHORT execution latch (Commit S1)
var bool  bearPBSeen    = false
var int   bearPBBar     = na
var int   lastBearShortExitBar = na   // Change 2: re-entry throttle

//====================================================
// BEAR diagnostics masks (LOG ONLY; no behavior impact)
// allowMask: which “good” gates were true
// vetoMask : which “blocking” conditions were true
//====================================================
int bearAllowMaskNow = 0
bearAllowMaskNow += bearShortADXOk ? 1 : 0              // bit 0: ADX ok
bearAllowMaskNow += bearCloseNearLowOk ? 2 : 0          // bit 1: close near low ok
bearAllowMaskNow += (not htfOnNow) ? 4 : 0              // bit 2: HTF not ON
bearAllowMaskNow += (pendingBear or bearActive) ? 8 : 0 // bit 3: bear context present

int bearVetoMaskNow = 0
bearVetoMaskNow += (not bearShortADXOk) ? 1 : 0
bearVetoMaskNow += (not bearCloseNearLowOk) ? 2 : 0
bearVetoMaskNow += (htfOnNow) ? 4 : 0
bearVetoMaskNow += (not (pendingBear or bearActive)) ? 8 : 0

var int bearReclaimCloseCnt = 0
var int   lastRBShortExitBar = na

// ---- RB SHORT execution latch (Commit S2)
var bool rbSPBSeen = false
var int  rbSPBBar  = na
var float rbSValue = na
var bool rbFromPBBlock = false


// ---- Bull acceptance-up (armed -> retest -> reclaim)
var bool  pendingBull   = false
var int   pendingBullBar= na
var bool  bullArmed     = false
var int   bullArmedBar  = na
var bool  bullPBSeen    = false
var int   bullPBBar     = na
var float bullPBLow     = na
var float bullStructLow = na
var int   bullStartBar = na
var float bullStartY   = na
// --- Bull-leg (regime) stall tracking (works even when flat) ---
var float bullLegHi = na
var int   bullLegNoNewHiStreak = 0
var int   bullEndBar   = na
var float bullEndY     = na
var bool bullTP1Done = false
var bool bullTP0Done = false
var bool bearTP1Done = false 
var bool bearTP0Done = false 
var int bearTP0Bar = na 
var float bearTP0Lo = na 
var float bearTP0EntryPx = na
var int bullNoNewHiStreak = 0
var int bullLastAddBar = na
var float bullAddRefHi = na   // last add/entry reference high-water mark
var float bullHH = na
var int   bullHHBar = na
var float bullArmRollHigh = na   // Option C: rollHigh snapshot at arm (accept-up)

// --- PB Freshness state ---
var int bullLastMajorImpulseBar = na
// --- PB Retry-after-Impulse-Chase latch (blocks retry PBs on same impulse after impulse-chase veto) ---
var int  pbChaseFailKey    = na
var bool pbChaseFailActive = false

float bullTrailLevel = na
// --- Bull impulse entry one-shot latch ---
var bool bullImpulseDone = false
var int bullLastExpansionBar = na

//====================================================
// Layer-1: Trade snapshot vars (ENTRY + PENDING)
//=====================================================

// Use int for Mode snapshot (stable for CSV). Map Mode->int via a small helper below.
var string   L1_modeEnt       = na
var float L1_modeScoreEnt  = na
var float L1_adxEnt        = na
var int  L1_adxRisingEnt  = na
var float L1_bodyPctEnt    = na
var float L1_closeLocEnt   = na
var float L1_rngAtrEnt     = na

var float L1_distBullATR   = na
var float L1_distEFATR     = na
var float L1_distESATR     = na

var int   L1_bsiEnt        = na
var int   L1_bsaEnt        = na
var int   L1_bsrEnt        = na

var int   L1_addCount      = 0
var bool  L1_tp1Hit        = false
var bool  L1_trailEver     = false

// ---- PB ENTRY SNAPSHOT (latched at PB fill; na for non-PB trades) ----
var int L1_pbVetoMaskEnt         = na
var int L1_pbMajorImpulseEnt     = na   // 1/0
var int L1_pbImpulseAgeBarsEnt   = na
var int L1_pbStallCountEnt       = na
var int L1_pbHighFailEnt         = na   // 1/0
var int L1_pbScoreEnt            = na

// ---- PB ENTRY SNAPSHOT (expanded) ----
var float L1_pbAdxSlopeEnt       = na
var int   L1_pbAgeBarsEnt        = na
var int   L1_pbNoNewHiStreakEnt  = na
var float L1_pbDepthAtrEnt       = na
var int   L1_pbExpAgeBarsEnt     = na
var int   L1_pbTouchOkEnt        = na // 1/0
var int   L1_pbHHProofOkEnt      = na // 1/0

// ---- BEAR ENTRY SNAPSHOT (committed at fill; na for non-BEAR trades) ----
var int   L1_bearPendingEnt      = na
var int   L1_bearActiveEnt       = na
var float L1_bearBreakLvlEnt     = na
var float L1_bearReclLvlEnt      = na
var int   L1_bearReclaimCntEnt   = na
var int   L1_bearPBSeenEnt       = na
var int   L1_bearPBBarEnt        = na
var int   L1_lastBearExitBarEnt  = na
var int   L1_bearShortADXOkEnt   = na
var int   L1_bearCloseNearLowEnt = na
var float L1_bearAdxSlopeEnt     = na
var int   L1_bearHtfOnEnt        = na
var string L1_bearHtfFlipEnt     = ""
var int   L1_bearAllowMaskEnt    = na
var int   L1_bearVetoMaskEnt     = na

// L1-only: defer PB snapshot reset until AFTER L1 closedtrades rows are emitted on the flat bar
var bool L1_pbResetPending = false

// --- “Pending” snapshot (captured at signal bar, then copied on actual entry) ---
var string   L1_pendMode        = na
var float L1_pendModeScore   = na
var float L1_pendAdx         = na
var int  L1_pendAdxRising   = na
var float L1_pendBodyPct     = na
var float L1_pendCloseLoc    = na
var float L1_pendRngAtr      = na

var float L1_pendDistEFATR   = na
var float L1_pendDistESATR   = na
var float L1_pendDistBullATR = na

var int   L1_pendBSI         = na
var int   L1_pendBSA         = na
var int   L1_pendBSR         = na



// ---- Range-A snapshot + structure
var float raStructLow = na
var float raDL_low    = na
var float raDL_high   = na
var float raDL_mid    = na
var int   raDL_bar    = na
var float raTPMid     = na
var float raStopBase  = na
var int   raEntryBar  = na
var bool raStructSnapOk = false
var bool raBalSnapOk = false


// ---- Range-B (Re-Anchor) state
// Phase 1: detect break w/out acceptance -> pendingReanchor
// Phase 2: confirm new balance outside old range -> rangeBActive
var bool  rbPending   = false
var bool  rbActive    = false
var int   rbDir       = 0      // +1 up reanchor, -1 down reanchor
var int   rbStartBar  = na
var float rbOldLow    = na
var float rbOldHigh   = na
var float rbOldMid    = na
var float rbNewLow    = na
var float rbNewHigh   = na
var float rbNewMid    = na

// ---- RB break-attempt staging (explicit "attempt without acceptance" trigger)
var bool  rbAttempt    = false
var int   rbAttemptDir = 0      // +1 up attempt, -1 down attempt
var int   rbAttemptBar = na
var float rbAttOldLow  = na
var float rbAttOldHigh = na
var float rbAttOldMid  = na


// ---- Trade tracking for time-stops and MFE
var int   lastEntryBar = na
var float tradeHi      = na
var float tradeLo      = na



// Defer resets until we are truly flat (calc_on_every_tick safety)
var bool pendingReset = false
var bool bearForceCloseShort = false

//====================================================
// LAYER 1 — Trade-level CSV export to Pine Logs
//====================================================

//------------------------------
// L1 join keys (Layer-1 ↔ Layer-2)
//------------------------------
string L1_tf = timeframe.period
var   string L1_runId = na                     // constant per backtest run
var   string L1_scriptVer = na                 // strategy title/version
var   int    L1_tradeSeq = 0                   // internal trade counter (monotonic)

// Init once
if barstate.isfirst
    // RunId: stable enough per run; uses first bar time + ticker + title
    // (No commas to keep CSV safe.)
    L1_scriptVer := str.replace_all(STRAT_TITLE, ",", ";")
    string _t0 = str.tostring(time)  // ms
    L1_runId := str.replace_all((syminfo.ticker + "|" + L1_tf + "|" + L1_scriptVer + "|" + _t0), ",", ";")

//------------------------------
// L1 helpers
//------------------------------


L1_mfePct(_dir, _entryPx, _maxFavPx) =>
    float q = _dir == "LONG" ? (_maxFavPx - _entryPx) : (_entryPx - _maxFavPx)
    _entryPx != 0 ? (q / _entryPx) * 100.0 : na

L1_maePct(_dir, _entryPx, _maxAdvPx) =>
    float q = _dir == "LONG" ? (_entryPx - _maxAdvPx) : (_maxAdvPx - _entryPx)
    _entryPx != 0 ? (q / _entryPx) * 100.0 : na

endsWith(string s, string suf) =>
    ls = str.length(s)
    lf = str.length(suf)
    ls >= lf and str.substring(s, ls - lf, ls) == suf


//====================================================
// Entry quality flags (bitmask)
// A=accept ok, R=retest/reclaim ok, H=HTF ok, X=not extended ok
//====================================================
const int Q_A = 1
const int Q_R = 2
const int Q_H = 4
const int Q_X = 8

qualMask(_A, _R, _H, _X) =>
    int m = 0
    m += _A ? Q_A : 0
    m += _R ? Q_R : 0
    m += _H ? Q_H : 0
    m += _X ? Q_X : 0
    m


// Trade id
var int   L1_tradeId = 0

// Pending entry info (latched at signal, committed on actual fill)
var string L1_pendDir   = ""
var string L1_pendReg   = ""
var string L1_pendArch  = ""

// ---- NEW: mandatory entry diagnostics (pending, committed on fill) ----
var string L1_pendEntryEngine   = ""   // e.g., BULL_START, BULL_PB, BULL_COMP, BULL_ADD, RA_ENTRY, RB_SHORT, BEAR_ENTRY
var string L1_pendHtfState      = ""   // HTF_ON / HTF_OFF
var string L1_pendHtfFlipEvent  = ""   // HTF_ON / HTF_OFF / NONE (most recent confirmed flip on this bar)
var string L1_pendLastFlipType  = ""   // START_BULL / END_BULL / NONE (bull flip type)
var int    L1_pendAcceptUpCnt   = na   // accept-up streak count at entry
var int    L1_pendQualMask      = 0    // entryQualityFlags bitmask

// Committed entry info (set on posOpened)
var string L1_coin      = ""
var string L1_dir       = ""
var string L1_regEntry  = ""
var string L1_regExit   = ""
var string L1_arch      = ""

// ---- NEW: committed entry diagnostics (written to CSV on close) ----
var string L1_entryEngine  = ""
var string L1_htfStateEnt  = ""
var string L1_htfFlipEnt   = ""
var string L1_lastFlipEnt  = ""
var int    L1_acceptUpEnt  = na
var int    L1_qualMaskEnt  = 0


var int    L1_entryTime = na
var float  L1_entryPx   = na
var float  L1_entrySize = na
var float  L1_entryEq   = na
var float  L1_entryNP   = na
var int    L1_entryBar  = na

// Max favorable / adverse tracking
var float  L1_maxFavPx  = na
var int    L1_maxFavBar = na
var float  L1_maxAdvPx  = na
var int    L1_maxAdvBar = na

// Pending exit info (latched at full-close, committed on posClosed)
var bool   L1_exitPending = false
var string L1_exitReason  = ""
var int    L1_exitOutcome = na

// ---- L1 partial-exit aggregates (kept per full trade) ----
var int    L1_nPartials         = 0
var float  L1_partialPctSum     = 0.0
var int    L1_firstPartialBar   = na
var int    L1_firstPartialTime  = na
var int    L1_lastPartialBar    = na
var int    L1_lastPartialTime   = na
var string L1_partialReasons    = ""
// ---- L1 realized PnL accumulator (source of truth = strategy.closedtrades.profit) ----
var int   L1_ctPrev = 0
var float L1_realizedPnlUsd = 0.0


// Emit header once (only when export is ON)
if exportToLogs and barstate.isfirst
    log.info(
      "runId,tf,scriptVer,tradeSeq," +
      "tradeId,coin,direction,tvEntryId,tvExitId," +
      "entryEngine,htfStateAtEntry,htfFlipEvent,lastFlipType,acceptUpCountAtEntry,entryQualityFlags," +
      "entryDatetime,exitDatetime," +
      "entryTimeMs,exitTimeMs," +
      "entryBarIndex,exitBarIndex," +
      "entryPrice,exitPrice,positionSize," +
      "netPnlUsd,tvPnlPct," +
      "mfePct,maePct," +
      "barsInTrade," +
      "exitReason," +
      "EXIT_ENGINE_DEACTIVATE," +
      "EXIT_STOP_STRUCT,EXIT_TIME_STOP,EXIT_HTF_FLIP,EXIT_TRAIL,EXIT_REGIME_CHANGE,EXIT_BULL_MOM_LOSS," +
      "regimeAtEntry,regimeAtExit," +

      "entryArchetype," +
      "maxFavorableBarIndex,maxAdverseBarIndex," +
      "tradeId_dup_entryBarIndex,tradeId_dup_exitBarIndex," +

      // ---- ENTRY CONTEXT SNAPSHOT (FULL) ----
      "modeAtEntry,modeScoreAtEntry," +
      "adxAtEntry,adxRisingAtEntry," +
      "bodyPctAtEntry,closeLocAtEntry,rngAtrAtEntry," +

      "distBullATR,distEFATR,distESATR," +
      "bsiAtEntry,bsaAtEntry,bsrAtEntry," +

      // ---- MONETIZATION / MANAGEMENT ----
      "tp1Hit,trailEver,addCount," +
      "pbVetoMaskEnt,pbMajorImpulseEnt,pbImpulseAgeBarsEnt,pbStallCountEnt,pbHighFailEnt,pbScoreEnt," +
      "pbAdxSlopeEnt,pbAgeBarsEnt,pbNoNewHiStreakEnt,pbDepthAtrEnt,pbExpAgeBarsEnt,pbTouchOkEnt,pbHHProofOkEnt," +
      "bearPendingEnt,bearActiveEnt,bearBreakLvlEnt,bearReclLvlEnt,bearReclaimCntEnt,bearPBSeenEnt,bearPBBarEnt,lastBearExitBarEnt," +
      "bearShortADXOkEnt,bearCloseNearLowEnt,bearAdxSlopeEnt,bearHtfOnEnt,bearHtfFlipEnt,bearAllowMaskEnt,bearVetoMaskEnt" +
      "bearReclLvl,bearInvNeed2Cl,bearReclaimCnt,bearTP0Done,bearTP1Done,bearFailState,bearBarsIn,bearMFEpct,bearMAEpct,bearReclLvlEff"
      )


// PBDBG header (separate stream; rowType=PBDBG)
if exportToLogs and dbgPBProbe and barstate.isfirst
    log.info(
      "rowType,runId,tf,scriptVer,coin," +
      "pbStatus,barIndex,datetime,timeMs," +
      "close,atr,bullLevel,emaFast," +
      "distBullATR,distEFAtr," +
      "pbAgeBars,bullLegNoNewHiStreak,pbDepthATR," +
      "pbImpulseAgeBars,pbFreshVeto," +
      "pbExtended,pbShallow,pbExhaustVeto,pbLateStallVeto,pbLifecycleVeto,pbTouchOk," +
      "bullPBEnter,bullPBEnterExec," +
      "bullStartBar,bullPBMaxAgeBars,pbAgeVeto,modeNow,bullArmedNow"
    )



// Helper: safe datetime formatting (Pine v6)
fmtDT(_t) =>
    // _t is ms since epoch; format in the chart's timezone
    str.format_time(_t, "yyyy-MM-dd HH:mm", logTZ)


// Helper: latch an exit (PURE function: returns new values, no global mutation)
L1_markExit(_reason, _outcome, _regExit) =>
    [true, _reason, _outcome, _regExit]

// Prefer TradingView "Signal" text (order comment). Fallback to id if comment is empty.
sigOrId(_comment, _id) =>
    string s = na(_comment) ? "" : _comment
    s := str.trim(s)
    s != "" ? s : _id


//------------------------------
// L1 trade lifecycle detection
//------------------------------
posOpened = barstate.isconfirmed and (strategy.position_size != 0) and (strategy.position_size[1] == 0)
posClosed = barstate.isconfirmed and (strategy.position_size == 0) and (strategy.position_size[1] != 0)

//------------------------------
// L1: commit pending entry snapshot on actual fill (posOpened)
//------------------------------
if posOpened
    // Core committed entry diagnostics
    L1_coin        := str.replace_all(syminfo.ticker, ",", ";")
    L1_dir         := L1_pendDir
    L1_regEntry    := L1_pendReg
    L1_arch        := L1_pendArch

    L1_entryEngine := L1_pendEntryEngine
    L1_htfStateEnt := L1_pendHtfState
    L1_htfFlipEnt  := L1_pendHtfFlipEvent
    L1_lastFlipEnt := L1_pendLastFlipType
    L1_acceptUpEnt := L1_pendAcceptUpCnt
    L1_qualMaskEnt := L1_pendQualMask

    // Full context snapshot (copied from pending) 
    L1_modeEnt      := L1_pendMode
    L1_modeScoreEnt := L1_pendModeScore
    L1_adxEnt       := L1_pendAdx
    L1_adxRisingEnt := L1_pendAdxRising
    L1_bodyPctEnt   := L1_pendBodyPct
    L1_closeLocEnt  := L1_pendCloseLoc
    L1_rngAtrEnt    := L1_pendRngAtr
    L1_distEFATR    := L1_pendDistEFATR
    L1_distESATR    := L1_pendDistESATR
    L1_distBullATR  := L1_pendDistBullATR
    L1_bsiEnt       := L1_pendBSI
    L1_bsaEnt       := L1_pendBSA
    L1_bsrEnt       := L1_pendBSR

    // Trade tracking anchors (optional but consistent)
    L1_entryTime := time
    L1_entryBar  := bar_index

    // ---- BEAR diagnostics snapshot (only meaningful for SHORT entries) ----
    if (L1_pendDir == "SHORT") and (L1_pendReg == "BEAR")
        L1_bearPendingEnt      := pendingBear ? 1 : 0
        L1_bearActiveEnt       := bearActive ? 1 : 0
        L1_bearBreakLvlEnt     := bearBreakLvl
        L1_bearReclLvlEnt      := bearReclLvl
        L1_bearReclaimCntEnt   := bearReclaimCloseCnt
        L1_bearPBSeenEnt       := bearPBSeen ? 1 : 0
        L1_bearPBBarEnt        := bearPBBar
        L1_lastBearExitBarEnt  := lastBearShortExitBar
        L1_bearShortADXOkEnt   := bearShortADXOk ? 1 : 0
        L1_bearCloseNearLowEnt := bearCloseNearLowOk ? 1 : 0
        L1_bearAdxSlopeEnt     := adxSlopeNow
        L1_bearHtfOnEnt        := htfOnNow ? 1 : 0
        L1_bearHtfFlipEnt      := htfFlipEventNow
        L1_bearAllowMaskEnt    := bearAllowMaskNow
        L1_bearVetoMaskEnt     := bearVetoMaskNow
    else
        // Keep non-BEAR trades clean (na) so parsing is trivial
        L1_bearPendingEnt      := na
        L1_bearActiveEnt       := na
        L1_bearBreakLvlEnt     := na
        L1_bearReclLvlEnt      := na
        L1_bearReclaimCntEnt   := na
        L1_bearPBSeenEnt       := na
        L1_bearPBBarEnt        := na
        L1_lastBearExitBarEnt  := na
        L1_bearShortADXOkEnt   := na
        L1_bearCloseNearLowEnt := na
        L1_bearAdxSlopeEnt     := na
        L1_bearHtfOnEnt        := na
        L1_bearHtfFlipEnt      := ""
        L1_bearAllowMaskEnt    := na
        L1_bearVetoMaskEnt     := na


// L1-only: defer PB snapshot reset until AFTER L1 closedtrades rows are emitted on the flat bar
if posClosed
    L1_pbResetPending := true

//====================================================
// L1: TradingView Trade List 1:1 logging
// Each strategy.closedtrades[] record == one row in Trade List
// This includes partial closes (TP1) as separate rows.
//====================================================

// Tracks how many closedtrades records we have already emitted to logs
var int L1_ctLogged = 0

if exportToLogs and barstate.isconfirmed
    int ctNow = strategy.closedtrades

    // Emit one CSV row per NEW closedtrades record (TP1 partials included)
    if ctNow > L1_ctLogged
        for k = L1_ctLogged to ctNow - 1
            // --- Trade List primitives (source of truth) ---
            int   eTime   = strategy.closedtrades.entry_time(k)
            int   xTime   = strategy.closedtrades.exit_time(k)
            int   eBar    = strategy.closedtrades.entry_bar_index(k)
            int   xBar    = strategy.closedtrades.exit_bar_index(k)
            float ePx     = strategy.closedtrades.entry_price(k)
            float xPx     = strategy.closedtrades.exit_price(k)
            float sz      = strategy.closedtrades.size(k)                 // signed (long +, short -)
            float qtyAbs  = math.abs(sz)
            float pnlUsd  = strategy.closedtrades.profit(k)
            float tvPnlPct= strategy.closedtrades.profit_percent(k)
            string dir    = sz >= 0 ? "LONG" : "SHORT"

            // Trade List IDs (best 1:1 identity you can get from Pine)
            // Trade List identity + Signal (comment) — Signal is what TradingView shows in "List of trades"
            string entryId  = strategy.closedtrades.entry_id(k)
            string exitId   = strategy.closedtrades.exit_id(k)
            string entryCmt = strategy.closedtrades.entry_comment(k)
            string exitCmt  = strategy.closedtrades.exit_comment(k)

            // Keep field names tvEntryId/tvExitId for CSV stability, but now they match TV "Signal" 1:1.
            string tvEntryId = sigOrId(entryCmt, entryId)
            string tvExitId  = sigOrId(exitCmt,  exitId)


            // Keep your field name, but make it explicit that it is TV's exit_id
            string exitReason = tvExitId

            // ----------------------------------------------------
            // Exit reason instrumentation: ENGINE_DEACTIVATE
            // ----------------------------------------------------
            // "Close entry(s) order ..." is TradingView's exit_id when the strategy closes without a typed comment.
            // We classify it as ENGINE_DEACTIVATE only if no other typed exit class fired.
            isTVUntypedClose = str.contains(tvExitId, "Close entry(s) order")

            
            // --- Exit-reason instrumentation (0/1 flags), derived from TV exit_id (== your close comment) ---
            // Structural stops / invalidations
            int EXIT_STOP_STRUCT = (tvExitId == "BULL_INV" or tvExitId == "BEAR_INV" or tvExitId == "RB_INV" or tvExitId == "RA_STOP") ? 1 : 0

            // Time-stops (your conventions use *_TS)
            int EXIT_TIME_STOP = endsWith(tvExitId, "_TS") ? 1 : 0

            // HTF flip on the current bar (NOTE: correct for newly-emitted records, because they occur on this bar)
            int EXIT_HTF_FLIP = (tvExitId == "HTF_OFF_CUT" or tvExitId == "HTF_FLIP") ? 1 : 0

            // Trail exits (reserved — becomes 1 once you emit e.g. "BULL_TRAIL" as an exit id/comment)
            int EXIT_TRAIL = str.contains(tvExitId, "TRAIL") ? 1 : 0

            // Regime-change exits (kill-switch / forced regime exit)
            int EXIT_REGIME_CHANGE = (tvExitId == "BEAR_KILL" or tvExitId == "BEAR_EXPIRE_FORCE") ? 1 : 0

            // If you already have your 5 exit flags implemented, this is the safest gating:
            EXIT_ENGINE_DEACTIVATE = isTVUntypedClose and (EXIT_STOP_STRUCT == 0) and (EXIT_TIME_STOP == 0) and (EXIT_HTF_FLIP == 0) and (EXIT_TRAIL == 0) and (EXIT_REGIME_CHANGE == 0) ? 1 : 0

            int EXIT_BULL_MOM_LOSS = (tvExitId == "BULL_MOM_LOSS" or exitReason == "BULL_MOM_LOSS") ? 1 : 0

            // Regime at exit: use current mode tagging at the bar the exit happens
            // (for partial exits while still in position, this is correct "at time of exit")
            string regExit = logModeNow()

            // Bars in trade for THIS closed record
            int barsInTrade = (not na(eBar) and not na(xBar)) ? (xBar - eBar) : na

            // MFE/MAE (percent): use TradingView closedtrades excursion stats (works per closed record, including partials).
            float ruUsd = strategy.closedtrades.max_runup(k)      // max favorable excursion in account currency for this closed record
            float ddUsd = strategy.closedtrades.max_drawdown(k)   // max adverse excursion in account currency for this closed record (typically negative)
            float notional = math.abs(ePx * sz)                   // approximate notional used to express excursion as percent

            float mfePct = notional > 0 ? (ruUsd / notional) * 100.0 : na
            float maePct = notional > 0 ? (-math.abs(ddUsd) / notional) * 100.0 : na

            // Trade Seq MUST match TradingView’s Trade List row ordering:
            // closedtrades are 0..N-1, so +1 gives a clean 1-based sequence.
            int tradeSeq = k + 1

            // Per-row monetization flags (1:1 with TradingView closedtrades records)
            bool tp1HitRow    = (tvExitId == "BULL_TP1") or (tvExitId == "BEAR_TP1")
            bool trailEverRow = str.contains(tvExitId, "TRAIL")

            log.info(
                 L1_runId + "," + L1_tf + "," + L1_scriptVer + "," + str.tostring(tradeSeq) + "," +
                 str.tostring(tradeSeq) + "," +
                 str.replace_all(syminfo.ticker, ",", ";") + "," + dir + "," +
                 str.replace_all(tvEntryId, ",", ";") + "," +
                 str.replace_all(tvExitId, ",", ";") + "," +

                 // Entry diagnostics (from your committed snapshot; same for TP1 + final exits)
                 str.replace_all(L1_entryEngine, ",", ";") + "," +
                 str.replace_all(L1_htfStateEnt, ",", ";") + "," +
                 str.replace_all(L1_htfFlipEnt, ",", ";") + "," +
                 str.replace_all(L1_lastFlipEnt, ",", ";") + "," +
                 str.tostring(L1_acceptUpEnt) + "," +
                 str.tostring(L1_qualMaskEnt) + "," +

                 // Entry/Exit datetimes + ms
                 fmtDT(eTime) + "," + fmtDT(xTime) + "," +
                 str.tostring(eTime) + "," + str.tostring(xTime) + "," +

                 // Entry/Exit bars
                 str.tostring(eBar) + "," + str.tostring(xBar) + "," +

                 // Prices + size
                 str.tostring(ePx) + "," + str.tostring(xPx) + "," + str.tostring(qtyAbs) + "," +

                 // PnL (USD + TradingView %)
                 str.tostring(pnlUsd) + "," + str.tostring(tvPnlPct) + "," +

                 // Excursions (na here by design for strict parity)
                 str.tostring(mfePct) + "," + str.tostring(maePct) + "," +

                 // Duration + exit reason + regimes
                str.tostring(barsInTrade) + "," +
                str.replace_all(exitReason, ",", ";") + "," +
                str.tostring(EXIT_ENGINE_DEACTIVATE) + "," +
                str.tostring(EXIT_STOP_STRUCT) + "," +
                str.tostring(EXIT_TIME_STOP) + "," +
                str.tostring(EXIT_HTF_FLIP) + "," +
                str.tostring(EXIT_TRAIL) + "," +
                str.tostring(EXIT_REGIME_CHANGE) + "," +
                str.tostring(EXIT_BULL_MOM_LOSS) + "," +
                str.replace_all(L1_regEntry, ",", ";") + "," +
                str.replace_all(regExit, ",", ";") + "," +

                 // Archetype + bars
                 str.replace_all(L1_arch, ",", ";") + "," +
                 str.tostring(L1_maxFavBar) + "," +
                 str.tostring(L1_maxAdvBar) + "," +

                 // duplicates
                 str.tostring(eBar) + "," + str.tostring(xBar) + "," +

                 // ENTRY CONTEXT SNAPSHOT
                 str.replace_all(L1_modeEnt, ",", ";") + "," +
                 str.tostring(L1_modeScoreEnt) + "," +
                 str.tostring(L1_adxEnt) + "," +
                 str.tostring(L1_adxRisingEnt) + "," +
                 str.tostring(L1_bodyPctEnt) + "," +
                 str.tostring(L1_closeLocEnt) + "," +
                 str.tostring(L1_rngAtrEnt) + "," +
                 str.tostring(L1_distBullATR) + "," +
                 str.tostring(L1_distEFATR) + "," +
                 str.tostring(L1_distESATR) + "," +
                 str.tostring(L1_bsiEnt) + "," +
                 str.tostring(L1_bsaEnt) + "," +
                 str.tostring(L1_bsrEnt) + "," +

                 // Monetization/management flags (still meaningful)
                 str.tostring(tp1HitRow) + "," + 
                 str.tostring(trailEverRow) + "," + 
                 str.tostring(L1_addCount) + "," +
                 str.tostring(L1_pbVetoMaskEnt) + "," +
                 str.tostring(L1_pbMajorImpulseEnt) + "," +
                 str.tostring(L1_pbImpulseAgeBarsEnt) + "," +
                 str.tostring(L1_pbStallCountEnt) + "," +
                 str.tostring(L1_pbHighFailEnt) + "," +
                 str.tostring(L1_pbScoreEnt) + "," + 
                 str.tostring(L1_pbAdxSlopeEnt) + "," + 
                 str.tostring(L1_pbAgeBarsEnt) + "," + 
                 str.tostring(L1_pbNoNewHiStreakEnt) + "," + 
                 str.tostring(L1_pbDepthAtrEnt) + "," + 
                 str.tostring(L1_pbExpAgeBarsEnt) + "," + 
                 str.tostring(L1_pbTouchOkEnt) + "," + 
                 str.tostring(L1_pbHHProofOkEnt) + "," + 
                 str.tostring(L1_bearPendingEnt) + "," + 
                 str.tostring(L1_bearActiveEnt) + "," + 
                 str.tostring(L1_bearBreakLvlEnt) + "," + 
                 str.tostring(L1_bearReclLvlEnt) + "," + 
                 str.tostring(L1_bearReclaimCntEnt) + "," + 
                 str.tostring(L1_bearPBSeenEnt) + "," + 
                 str.tostring(L1_bearPBBarEnt) + "," + 
                 str.tostring(L1_lastBearExitBarEnt) + "," + 
                 str.tostring(L1_bearShortADXOkEnt) + "," + 
                 str.tostring(L1_bearCloseNearLowEnt) + "," + 
                 str.tostring(L1_bearAdxSlopeEnt) + "," + 
                 str.tostring(L1_bearHtfOnEnt) + "," + 
                 str.replace_all(L1_bearHtfFlipEnt, ",", ";") + "," + 
                 str.tostring(L1_bearAllowMaskEnt) + "," + 
                 str.tostring(L1_bearVetoMaskEnt)
            )

        // Advance the emitted pointer
        L1_ctLogged := ctNow
        // Apply deferred PB snapshot reset only after L1 has logged the newly closed trade rows
        if L1_pbResetPending and (strategy.position_size == 0)
            L1_pbVetoMaskEnt       := na
            L1_pbMajorImpulseEnt   := na
            L1_pbImpulseAgeBarsEnt := na
            L1_pbStallCountEnt     := na
            L1_pbHighFailEnt       := na
            L1_pbScoreEnt          := na
            L1_pbAdxSlopeEnt := na
            L1_pbAgeBarsEnt := na
            L1_pbNoNewHiStreakEnt := na
            L1_pbDepthAtrEnt := na
            L1_pbExpAgeBarsEnt := na
            L1_pbTouchOkEnt := na
            L1_pbHHProofOkEnt := na
            L1_pbResetPending := false

//====================================================
// Bull ADD diagnostics — counters (must be declared BEFORE bullAddEnter is computed)
//====================================================
var int   c_addSig   = 0     // bullAddEnter was true (signal)
var int   c_addFill  = 0     // position size increased (actual fill)
var int   c_tp1Hits  = 0     // TP1 executed
var float prevPosSize = na

// ADD gate diagnostics
var int c_addPB      = 0
var int c_addReclaim = 0
var int c_addBlkTP1  = 0
var int c_addBlkADX  = 0
var int c_addBlkExt  = 0
var int c_addBlkSpc  = 0
var int c_addBlkSlope = 0
var int c_addBlkNH    = 0
var int c_addBlkHTF   = 0
var int c_addBlkSlow  = 0
var int c_addBlkTrail = 0
var int c_bullStartSig = 0   // Bull START (impulse) signals
var int c_bullCompSig = 0
var int c_bullStartWin   = 0
var int c_bullStartStrong= 0
var int c_bullStartExt   = 0
var int c_bullStartADX   = 0
var int c_bullStartFinal = 0
var int c_bullStartNoChase = 0
var int c_bullStartMicroPB = 0
var int c_bullTrailArmed = 0   // Bull runner trail armed (confirmed bars)
var int c_bullTrailExit = 0

var int c_bearPBSeen = 0
var int c_bearBreakSig = 0
var int c_bearReentryOk = 0

bearAllowContinuation = bearActive and not pendingBear


//====================================================
// Balance detectors (Range-A + potential Range-B new balance)
//====================================================
raWidth = (rollHigh - rollLow)
raInBalance = (raWidth <= atr * raBalMaxWidth_ATR) and (math.abs(emaFast - emaSlow) <= atr * raBalMaxEMASep_ATR)

// Rolling for RB confirmation uses same rollHigh/rollLow; RB confirms via conditions below.

//====================================================
// Bear engine (Acceptance-down v1.3)
//====================================================
bearHTFOk = (not htfTrendOk) and (not htfNeutral)
// you can tighten to: (not htfTrendOk) and (not htfNeutral)

bearBreakNow = bearHTFOk and close < (decLow - atr * bearBuf_ATR)

if (not bearActive) and (not pendingBear) and bearBreakNow
    pendingBear  := true
    bearBreakLvl := (decLow - atr * bearBuf_ATR)
    bearReclLvl  := (decLow + atr * bearBuf_ATR)

bearAcceptOk = pendingBear and not na(bearBreakLvl) and (close < bearBreakLvl) and (not bearNeed2Cl or close[1] < bearBreakLvl)
if bearAcceptOk
    bearActive      := true
    pendingBear     := false
    bearAcceptedBar := bar_index
    bearRenewBar    := bar_index

    // ---- BEAR label anchor (STRUCTURE) ----
    bearStartBar := bar_index
    bearStartY   := high + lblPadUp
    bearEndBar   := na
    bearEndY     := na
        // ---- HARD CLEAR: Bear overlay cancels any Bull setup truth ----
    pendingBull    := false
    pendingBullBar := na
    bullArmed      := false
    bullArmedBar   := na
    bullPBSeen     := false
    bullPBBar      := na
    bullPBLow      := na
    bullStructLow  := na
    bullLevel      := na
    bullHH := na
    bullArmRollHigh := na
    bullHHBar := na


    // Also clear Bull label anchors so they cannot print inside Bear
    bullStartBar := na
    bullStartY   := na
    bullEndBar   := na
    bullEndY     := na

    // Reset bear SHORT latch on new Bear acceptance
    bearPBSeen := false
    //bearJustAccepted = bearActive and not na(bearAcceptedBar) and (bar_index == bearAcceptedBar)
    bearPBBar  := na

bearAcceptVetoLowAdx = (adx < 20)
bearAcceptVetoWeakWickPrev = (not na(adx[1])) and (not na(bodyPct[1])) and (adx[1] < 20) and (bodyPct[1] < 0.12)
bearAcceptImpulseEnter = barstate.isconfirmed and (not inPos) and bearShortOn and bearAcceptEntryOn and (bearActive and not na(bearAcceptedBar) and (bar_index == bearAcceptedBar)) and shortCooldownOk and bearShortADXOk and (adx >= bearShortADXMin) and (close < bearBreakLvl) and (close < open) and (bodyPct >= bearMinBodyPct) and bearCloseNearLowOk and (not bearAcceptVetoLowAdx)

// Cancel pendingBear if price reclaims above the reclaim level (close-based truth)
bearPendingCancel = pendingBear and not na(bearReclLvl) and (close > bearReclLvl) and (not bearNeed2Cl or close[1] > bearReclLvl)
if bearPendingCancel
    pendingBear  := false
    bearBreakLvl := na
    bearReclLvl  := na
    bearPBSeen := false
    bearPBBar  := na



bearReclaimOk = bearActive and not na(bearReclLvl) and (close > bearReclLvl) and (not bearNeed2Cl or close[1] > bearReclLvl)
if bearReclaimOk
    // ---- stamp END before wiping levels ----
    bearEndBar := bar_index
    bearEndY   := low - lblPadDown
    bearActive      := false
    bearBreakLvl    := na
    bearReclLvl     := na
    bearAcceptedBar := na
    bearRenewBar    := na
    bearPBSeen := false
    bearPBBar  := na



bearLockoutOk = (bearLockoutBars <= 0) or na(bearAcceptedBar) or ((bar_index - bearAcceptedBar) >= bearLockoutBars)
// ---- Bear renewal + expiry (prevents months-long latch)
// Renewal condition: fresh accept-down using CURRENT decision low (structure keeps proving bear control)
bearRenewNow = bearActive and bearBreakNow and (not bearNeed2Cl or close[1] < (decLow - atr * bearBuf_ATR))

if bearRenewNow
    bearRenewBar := bar_index
    if bearRenewTighten
        // Tighten snapshot levels to the latest break context (keeps reclaim relevant)
        bearBreakLvl := (decLow - atr * bearBuf_ATR)
        bearReclLvl  := (decLow + atr * bearBuf_ATR)



// Expiry: if bear control stops renewing, downgrade to Range-B (value migration / re-anchor)
bearExpired = bearActive and (bearMaxBars > 0) and (not na(bearRenewBar)) and ((bar_index - bearRenewBar) > bearMaxBars)
// If Bear expires while a BEAR short is still open, arm a forced close.
// NOTE: we do NOT close/log here because logTrade() is defined later in the script.
if bearExpired and inPos and (posTag == "BEAR") and isShort
    bearForceCloseShort := true

if bearExpired and (not inPos)
    
    // ---- stamp END at last known reclaim/structure context ----
    bearEndBar := bar_index
    bearEndY   := low - lblPadDown
    bearActive      := false
    pendingBear     := false
    bearBreakLvl    := na
    bearReclLvl     := na
    bearAcceptedBar := na
    bearRenewBar    := na

    // Force Range-B after Bear expires (avoids instant Range-A noise)
    forcedMode := Mode.RangeB
    forcedUntilBar := bar_index + downgradeBars
    bearForceCloseShort := false




// Bear kill-switch exit (acceptance below break level while long)
bearExitNow = inPos and (not na(bearBreakLvl)) and (close < bearBreakLvl) and (not bearNeed2Cl or close[1] < bearBreakLvl) and (not bearKillUseHTFveto or (not htfTrendOk))



//====================================================
// Bull engine (Trend v1.2) — accept-up -> retest-holds -> reclaim entry
//====================================================
crossUp = ta.crossover(close, rollHigh)

// Arm pending on breakout event (HTF-independent; acceptance truth is close-based)
// HARD VETO: do not arm Bull while Bear overlay is active/pending.
if (not inPos) and (not pendingBull) and (not bullArmed) and crossUp and (not bearActive) and (not pendingBear)
    pendingBull    := true
    pendingBullBar := bar_index
    bullLevel      := rollHigh
    // ---- Bull HH tracker (since START_BULL / accept-up) ----


// --- PB-Count (per bull leg) ---
var int bullPBCount = 0

// Accept-up = 2 closes above bullLevel
// HARD VETO: do not accept Bull while Bear overlay is active/pending.
bullAcceptUp = pendingBull and not na(bullLevel) and (close > bullLevel) and (not bearActive) and (not pendingBear) and
     (not bullAcceptNeed2Cl or close[1] > bullLevel)


if bullAcceptUp
    bullArmed       := true
    bullArmedBar    := bar_index
    bullArmRollHigh := rollHigh
    bullHH := na
    bullHHBar := na
    pendingBull     := false
    pendingBullBar  := na
    lastBullFlipType := "START_BULL"
    bullPBCount := 0
    rbFromPBBlock := false



    // ---- BULL label anchor (STRUCTURE) ----
    bullStartBar := bar_index
    bullStartY   := low - lblPadDown
        // Reset bull-leg stall tracking on new bull leg
    bullLegHi := high
    bullLegNoNewHiStreak := 0
    bullEndBar   := na
    bullEndY     := na
    bullImpulseDone := false


// --- START-BULL breakout entry (one-shot) ---
bullStartBreak = ta.highest(high[1], bullBreakLookback_T)

bool bullStartStrong =
     (bodyPct >= bullStartEntryBodyPct) and
     (close > bullLevel) and
     (close > open) and
     (close > bullStartBreak)

bool bullStartNotExtended =
     (not na(bullLevel)) and ((close - bullLevel) <= bullStartEntryMaxExt * atr)
bool bullStartNotExtendedEMA =
     (close <= emaFast + atr * bullStartEntryMaxExtEMA)

bool bullStartMicroPB =
     (low <= emaFast + atr * bullStartMicroPB_ATR) or
     (not na(bullLevel) and low <= bullLevel + atr * bullPB_ATR)

bool bullStartNoChase =
     (not na(bullLevel)) and ((close - bullLevel) <= atr * bullStartNoChaseMax_ATR)

bool bullStartADXok = adxBullExecOk
bool bullStartDmiOk = (not bullUseDMI) or (pdi > mdi)


// Allow only shortly after accept-up (window), before pullback entry exists, one-shot
bool bullStartInWindow =
     bullArmed and (not na(bullArmedBar)) and
     ((bar_index - bullArmedBar) >= 0) and ((bar_index - bullArmedBar) < bullStartWindowBars)

bool bullStartEntry = bullStartEntryOn and bullStartInWindow and (not bullPBSeen) and (not bullImpulseDone) and bullStartStrong and bullStartNotExtended and bullStartNotExtendedEMA and bullStartNoChase and (not bullStartRequireMicroPB or bullStartMicroPB) and bullStartADXok and bullStartDmiOk

if barstate.isconfirmed and (not inPos)
    // gate 1: window + state
    if bullStartEntryOn and bullStartInWindow and (not bullPBSeen) and (not bullImpulseDone)
        c_bullStartWin += 1

    // gate 2: impulse quality
    if bullStartEntryOn and bullStartInWindow and (not bullPBSeen) and (not bullImpulseDone) and bullStartStrong
        c_bullStartStrong += 1

    // gate 3: not extended (both tests)
    if bullStartEntryOn and bullStartInWindow and (not bullPBSeen) and (not bullImpulseDone) and bullStartStrong and bullStartNotExtended and bullStartNotExtendedEMA
        c_bullStartExt += 1

    // gate 4: exec ADX
    if bullStartEntryOn and bullStartInWindow and (not bullPBSeen) and (not bullImpulseDone) and bullStartStrong and bullStartNotExtended and bullStartNotExtendedEMA and bullStartADXok
        c_bullStartADX += 1

    // gate 4.5: no-chase
    if bullStartEntryOn and bullStartInWindow and (not bullPBSeen) and (not bullImpulseDone) and bullStartStrong and bullStartNotExtended and bullStartNotExtendedEMA and bullStartADXok and bullStartNoChase
        c_bullStartNoChase += 1

    // gate 4.6: micro pullback
    if bullStartEntryOn and bullStartInWindow and (not bullPBSeen) and (not bullImpulseDone) and bullStartStrong and bullStartNotExtended and bullStartNotExtendedEMA and bullStartADXok and bullStartNoChase and bullStartMicroPB
        c_bullStartMicroPB += 1

    // gate 5: final condition (should match c_bullStartSig)
    if bullStartEntry
        c_bullStartFinal += 1


if barstate.isconfirmed and (not inPos) and bullStartEntry
    c_bullStartSig += 1

bool bullAcceptCompression = false

// Cancel if lost acceptance before entry (buffered + optional 2-close, aligned with v1.0)
bullLostLvl = bullLevel - atr * bullInvBuf_ATR
bullLostAcceptance =
     bullArmed and (not inPos) and (not na(bullLevel)) and
     (close < bullLostLvl) and (not bullInvNeed2Cl or close[1] < bullLostLvl)

if bullLostAcceptance
    // ---- stamp END before wiping levels ----
    bullEndBar := bar_index
    bullEndY   := high + lblPadUp
    lastBullFlipType := "END_BULL"
    bullLegHi := na
    bullLegNoNewHiStreak := 0
    bullPBCount := 0
    bullArmed    := false
    bullArmedBar := na
    bullPBSeen   := false
    bullPBBar    := na
    bullPBLow    := na
    bullStructLow:= na
    bullLevel    := na
    pendingBull  := false
    pendingBullBar := na
    bullHH := na
    bullArmRollHigh := na
    bullHHBar := na



// Retest-that-holds detection (only after arming)
// STRICT: require price was ABOVE the retest zone on the prior bar (optional),
// then dips into the zone (pullback), and closes holding the level.
if bullArmed and (not inPos)
    // Track highest high AFTER accept-up bar (real structure proof)
    if barstate.isconfirmed and (not na(bullArmedBar)) and (bar_index > bullArmedBar)
        if na(bullHH) or (high > bullHH)
            bullHH := high
            bullHHBar := bar_index

    bool wasAboveZone = not na(bullLevel) and (high[1] > bullLevel + atr * bullPB_ATR)
    bool fromAboveOk  = (not bullPBRequireFromAbove) or wasAboveZone

    // --- Retest zone definitions (MUST exist before use) ---
    float zoneTop = bullLevel + atr * bullPB_ATR
    float zoneBot = bullLevel - atr * bullPB_MaxDip_ATR

    // Dip into zone: low enters the retest zone (above max dip constraint)
    bool dippedIntoZone = not na(bullLevel) and (low <= zoneTop) and (low >= zoneBot)

    // Close holds: close is above bullLevel (or very slightly under via allowance)
    bool pbCloseHolds = not na(bullLevel) and (close >= bullLevel - atr * bullLvlHold_ATR)

    // Low holds: intrabar low not meaningfully below bullLevel (soft structure hold)
    bool pbLowHolds = not na(bullLevel) and (low >= bullLevel - atr * bullPB_MaxDip_ATR)

    if (not bullPBSeen) and (bar_index > bullArmedBar + 1) and fromAboveOk and dippedIntoZone and pbCloseHolds and pbLowHolds
        bullPBSeen    := true
        bullPBBar     := bar_index
        bullPBLow     := low
        bullStructLow := low



// Expire stale pending bull (pre-accept) so it can't linger forever
bullPendingExpired = pendingBull and (not inPos) and not na(pendingBullBar) and ((bar_index - pendingBullBar) > bullArmMaxBars)
if bullPendingExpired
    pendingBull    := false
    pendingBullBar := na
    bullLevel      := na


// Expire stale bull setup
bullSetupExpired = bullArmed and (not inPos) and not na(bullArmedBar) and ((bar_index - bullArmedBar) > bullArmMaxBars)
if bullSetupExpired
    // ---- stamp END before wiping levels ----
    bullEndBar := bar_index
    bullEndY   := high + lblPadUp
    lastBullFlipType := "END_BULL"
    bullLegHi := na
    bullLegNoNewHiStreak := 0
    pendingBull   := false
    bullArmed     := false
    bullArmedBar  := na
    bullPBSeen    := false
    bullPBBar     := na
    bullPBLow     := na
    bullLevel     := na
    bullStructLow := na
    bullHH := na
    bullArmRollHigh := na
    bullHHBar := na



// Reclaim entry (after PBSeen) with hold
if bullPBSeen and (not inPos)
    bullStructLow := na(bullStructLow) ? low : math.min(bullStructLow, low)

bullHoldOk = bullPBSeen and (na(bullPBLow) ? true : (low >= bullPBLow - atr * bullHold_ATR))
bullBreakLvl = ta.highest(high[1], bullBreakLookback_T)

bullReclaimNow =
     bullArmed and bullPBSeen and bullHoldOk and
     (close > bullLevel) and (close > open) and (bodyPct >= bullMinBodyPct_T) and
     (close > bullBreakLvl)


//===================================================
// Bull Acceptance-Compression (no PB) — acceptance + tight compression + continuation-ready
//===================================================

// Close-location filter reused for COMP quality
bullCloseNearHighOk = closeLoc >= bullCompCloseNearHighMin

// Hold + no-chase constraints
bullCompHoldOk = bullArmed and not na(bullLevel) and (low >= bullLevel - atr * bullCompHold_ATR)
bullCompNotChase = bullArmed and not na(bullLevel) and ((close - bullLevel) <= atr * bullCompMaxExt_ATR)

// Acceptance-compression condition (PB did NOT happen; we are “accepted and compressing”)
bullAcceptCompression :=
     bullCompOn and
     bullArmed and (not bullPBSeen) and (not bullImpulseDone) and
     (close > bullLevel) and (close[1] > bullLevel) and
     (bodyPct <= bullCompMaxBodyPct) and
     bullCloseNearHighOk and
     bullCompHoldOk and bullCompNotChase and
     ((not bullUseDMI) or (pdi > mdi)) and
     adxBullPBExecOk and
     htfBullOk and
     (not bearActive) and (not pendingBear)

if barstate.isconfirmed and (not inPos) and bullAcceptCompression
    c_bullCompSig += 1


//====================================================
// Bull invalidation + runner trail (TP1+runner)
// IMPORTANT: bullTrailLevel MUST be defined here (before bullCloseInvalid)
//=====================================================

// Runner trail reference (EMA-based)
bullTrailEMA = bullTrailUseSlow ? emaSlow : emaFast
bullTrailLevel := bullTrailEMA - atr * bullTrailBuf_ATR
// Pre / Post TP1 structure levels
bullInvLevelPre  = bullLevel - atr * bullInvBuf_ATR
bullInvLevelPost = bullLevel - atr * bullInvAfterTP1Buf_ATR

// BEFORE TP1: strict structure invalidation
bullPreInvalid = inPos and (posTag == "BULL") and not na(bullLevel) and (not bullTP1Done) and (close < bullInvLevelPre) and (not bullInvNeed2Cl or close[1] < bullInvLevelPre)

// AFTER TP1: runner management (trail arms only after proof MFE)
bullMFE_now = (inPos and posTag == "BULL") ? (tradeHi - strategy.position_avg_price) : 0.0
bullTrailArmed = bullTP1Done and bullTrailOn and (bullMFE_now >= atr * bullTrailArm_ATR)
if exportToLogs and inPos and (posTag == "BULL") and bullTrailArmed
    L1_trailEver := true

bullPostTrailInvalid =
     inPos and (posTag == "BULL") and not na(bullLevel) and bullTrailArmed and
     (close < bullTrailLevel)

bullPostStructInvalid =
     inPos and (posTag == "BULL") and not na(bullLevel) and bullTP1Done and (not bullTrailArmed) and
     (close < bullInvLevelPost) and (not bullInvAfterTP1Need2Cl or close[1] < bullInvLevelPost)

bullCloseInvalid = bullPreInvalid or bullPostTrailInvalid or bullPostStructInvalid

// Bear SHORT invalidation (split: pre-TP1 vs post-TP1 runner protection)
bearInvPre =
     inPos and (posTag == "BEAR") and (not bearTP1Done) and not na(bearReclLvl) and
     (close > bearReclLvl) and (not bearInvNeed2Cl or close[1] > bearReclLvl)

bearProt0Level = (inPos and posTag == "BEAR") ? (strategy.position_avg_price + atr * bearProt0Buf_ATR) : na
bearInvPostTP0Protect =
     inPos and (posTag == "BEAR") and bearTP0Done and (not bearTP1Done) and not na(bearProt0Level) and
     (close > bearProt0Level) and (not bearProt0Need2Cl or close[1] > bearProt0Level)

// Post-TP1 protection stop: prevent TP1 winners from turning into reclaim/bull-kill losers
bearProtLevel = (inPos and posTag == "BEAR") ? (strategy.position_avg_price + atr * bearProtBuf_ATR) : na
bearInvPostProtect =
     inPos and (posTag == "BEAR") and bearTP1Done and not na(bearProtLevel) and
     (close > bearProtLevel) and (not bearProtNeed2Cl or close[1] > bearProtLevel)

// Post-TP1 trail: EMAfast + buffer (runner-style). After TP1 we stop using reclaim invalidation; BE+trail manage the runner.
bearTrailEMA = emaFast
bearTrailLevel = (inPos and posTag == "BEAR") ? (bearTrailEMA + atr * bearTrailBuf_ATR) : na
bearInvPostTrail = inPos and (posTag == "BEAR") and bearTP1Done and bearTrailOn and not na(bearTrailLevel) and (close > bearTrailLevel) and (not bearProtNeed2Cl or close[1] > bearTrailLevel)

// L1: BEAR trail armed/fired latch (auditable per full trade)
if exportToLogs and inPos and (posTag == "BEAR") and bearTP1Done and bearTrailOn and not na(bearTrailLevel)
    L1_trailEver := true

bearShortInvalid = bearInvPre or bearInvPostTP0Protect or bearInvPostProtect or bearInvPostTrail

// RB SHORT invalidation: reclaim above RB value boundary (close-based, optional 2-close)
rbSInvLvl = (not na(rbSValue) ? (rbSValue + atr * rbS_InvBuf_ATR) : na)
rbShortInvalid =
     inPos and (posTag == "RANGEB") and isShort and not na(rbSInvLvl) and
     (close > rbSInvLvl) and (not rbS_InvNeed2Cl or close[1] > rbSInvLvl)

//====================================================
// Range-A engine (Balanced v1.1-A) — decision-level discount + 2-close reclaim
//====================================================

// Sweep / fresh-low veto
freshLow = low < ta.lowest(low[1], lvlLookback)
sweepLvl = ta.lowest(low[1], sweepLen)
sweepReclaim = (low < sweepLvl) and (close > (sweepLvl + atr * 0.05))
raStructOk = (not raNeedSweep) or tuneRelaxSweep or freshLow or sweepReclaim

// Discount = excursion below decision low
raDiscNow = raInBalance and raStructOk and (low <= (decLow - atr * raDisc_ATR))
raDiscRecent := ta.barssince(raDiscNow) <= raDiscLookback

// Freeze snapshot when discount prints (flat only)
if (not inPos) and raDiscNow
    raStructLow := na(raStructLow) ? low : math.min(raStructLow, low)
    raDL_low  := decLow
    raDL_high := decHigh
    raDL_mid  := rollMid
    raDL_bar  := bar_index
    raStructSnapOk := raStructOk
    raBalSnapOk    := raInBalance   // <<< freeze BALANCE truth at discount time

// Prevent stale snapshot
if (not inPos) and (not raDiscRecent)
    raStructLow := na
    raDL_low    := na
    raDL_high   := na
    raDL_mid    := na
    raDL_bar    := na
    raStructSnapOk := false
    raBalSnapOk    := false

raSnapReady = (not na(raDL_low)) and (not na(raDL_bar)) and (bar_index > raDL_bar)

// Precompute history-dependent funcs every bar (avoids Pine warning)
raLowN   = ta.lowest(low,   raWasBelowLookback)
raCloseN = ta.lowest(close, raWasBelowLookback)

// Was below decision low recently (proof of reclaim, not chase)
raWasBelow = raSnapReady and (raLowN <= raDL_low or raCloseN <= raDL_low)


// Acceptance back above decision low = 2 closes
raAccept2Cl = raSnapReady and (close > raDL_low) and (close[1] > raDL_low)
// 1-close reclaim (first close back above DL_low)
raAccept1Cl = raSnapReady and (close > raDL_low) and (close[1] <= raDL_low)

// EXEC reclaim: either 2-close accept (strict) or 1-close reclaim (early), controlled by input
raReclaimExecOk = raWasBelow and (raExecNeed2Cl ? raAccept2Cl : raAccept1Cl)

// --- RA retest-that-holds (prevents “enter then dump” cases) ---
// Require strict 2-close acceptance, then a pullback that holds above DL_low.
raAccepted = raWasBelow and raAccept2Cl
raRetestTouch = raAccepted and (low <= raDL_low + atr * raRetestBuf_ATR)
raRetestHold  = raAccepted and raRetestTouch and (close > raDL_low) and (not raRetestNeedGreen or close > open)
raRetestOk    = (not raUseRetestEntry) or raRetestHold


// Entry must be near the decision low (avoid chasing; fixes risk-gate starvation)
// Near-low filter should be independent; risk is handled by raRiskOk/raMaxRisk_ATR gate below.
raNearLowOk = raSnapReady and (math.min(low, low[1]) <= raDL_low + atr * raMaxEntryAboveLow_ATR)
raBelowMidOk = raSnapReady and (not na(raDL_mid)) and (tuneRelaxBelowMid or (close < raDL_mid))

raReclaimOk = raWasBelow and raAccept2Cl

// RSI veto (must come AFTER raWasBelow + raAccept2Cl are defined)
raRsi = ta.rsi(close, raRsiLen)

// "Washout reclaim" = we proved price was below snapshot low and now accepted back above it (2 closes)
raWashoutReclaim = raWasBelow and raAccept2Cl

// RSI veto logic: keep it normally, but allow bypass on true washout reclaim
raRsiOk =
     (not raUseRSI) or
     (raRsi <= raRsiMax_T) or
     (raRsiWashoutBypass and raWashoutReclaim)


// Final RA entry gate (HTF OFF, not bear-active, in balance, discount recent, reclaim accepted, vetoes ok)
raEntryOkRaw = ( (not inPos) and htfOffForRA and bearLockoutOk and (not bearActive) and (raInBalance or raBalSnapOk) and raDiscRecent and raReclaimExecOk and raRetestOk and (not raUseNearLow or raNearLowOk) and (not raRequireBelowMid or raBelowMidOk) and raRsiOk and raStructSnapOk and adxRAOk )

// --- RA expectancy gates (mechanical, v1.0-aligned) ---
// Risk gate uses StructLow stopbase, but can fall back to DL_low if StructLow makes risk too large.
raEntryPx = close

// Candidate A: stop based on struct low
raStructGap_ATR = (not na(raStructLow) and not na(raDL_low) and atr > 0) ? ((raDL_low - raStructLow) / atr) : na
raStopBase_A = (not na(raStructLow) and (na(raStructGap_ATR) or raStructGap_ATR <= raStructStopMaxGap_ATR)) ? raStructLow : na
raStopCand_A = not na(raStopBase_A) ? (raStopBase_A - atr * raStop_ATR) : na
raRiskATR_A  = (not na(raStopCand_A) and atr > 0) ? ((raEntryPx - raStopCand_A) / atr) : na

// Candidate B: fallback stop based on decision low (tighter)
raStopBase_B = not na(raDL_low) ? raDL_low : na
raStopCand_B = not na(raStopBase_B) ? (raStopBase_B - atr * raStop_ATR) : na
raRiskATR_B  = (not na(raStopCand_B) and atr > 0) ? ((raEntryPx - raStopCand_B) / atr) : na

// Choose risk measure for gating
// Fallback must also engage when StructLow-based risk is NA (missing/invalid structure stopbase)
raUseFallback = raRiskFallbackToDL and (not na(raRiskATR_B)) and (na(raRiskATR_A) or (raRiskATR_A > raMaxRisk_ATR))
raRiskATR = raUseFallback ? raRiskATR_B : raRiskATR_A

// RR-to-mid (keep your existing RR gate; HUD shows RR=0 blocks)
raRewardATR = (not na(raDL_mid) and atr > 0) ? ((raDL_mid - raEntryPx) / atr) : na
raRR_ToMid  = (not na(raRiskATR) and raRiskATR > 0 and not na(raRewardATR)) ? (raRewardATR / raRiskATR) : na

raRiskOk = (not na(raRiskATR)) and (raRiskATR <= raMaxRisk_ATR)
raRROkSoft = (not na(raRR_ToMid)) and (raRR_ToMid >= raMinRR_ToMid)
raRROkHard = (not na(raRR_ToMid)) and (raRR_ToMid >= raMinRR_Hard)

raEntryOk = raEntryOkRaw and raRiskOk and raRROkHard
raDecision = (not inPos) and raSnapReady and raDiscRecent and raReclaimExecOk


//====================================================
// Range-B engine (Re-Anchor v1.1-B) — break w/out acceptance -> new balance -> resolution tree
//====================================================

// Step 1: detect BREAK ATTEMPT, then only start RB if ACCEPTANCE is NOT confirmed
upBreakNow   = close > decHigh
downBreakNow = close < decLow

// Acceptance checks (2 consecutive closes beyond the *decision* edge)
rbAccHigh = (rbUseSnapshotAccept and rbAttempt and not na(rbAttOldHigh)) ? rbAttOldHigh : decHigh
rbAccLow  = (rbUseSnapshotAccept and rbAttempt and not na(rbAttOldLow))  ? rbAttOldLow  : decLow

upAcceptNow   = (close > rbAccHigh) and (close[1] > rbAccHigh)
downAcceptNow = (close < rbAccLow)  and (close[1] < rbAccLow)

// 1) Stage a break ATTEMPT (capture old range snapshot at the moment of attempt)
if (not rbActive) and (not rbPending) and (not rbAttempt) and (upBreakNow or downBreakNow)
    rbAttempt    := true
    rbAttemptDir := upBreakNow ? 1 : -1
    rbAttemptBar := bar_index
    // Snapshot the buffered decision edges so "attempt acceptance" is consistent across bars
    rbAttOldLow  := decLow
    rbAttOldHigh := decHigh
    rbAttOldMid  := rollMid


// 2) Resolve the attempt:
//    - If acceptance confirms in the attempt direction => cancel attempt (no RB)
//    - If acceptance does NOT confirm by the next bar => start RB pending (explicit "attempt without acceptance")
if rbAttempt
    bool acceptConfirmed = false

    if (rbAttemptDir == 1) and upAcceptNow
        acceptConfirmed := true
    if (rbAttemptDir == -1) and downAcceptNow
        acceptConfirmed := true

    if acceptConfirmed
        rbAttempt    := false
        rbAttemptDir := 0
        rbAttemptBar := na
        rbAttOldLow  := na
        rbAttOldHigh := na
        rbAttOldMid  := na
    else
        // Wait at least 1 bar after the attempt bar so the 2-close acceptance has a chance to confirm
        if not na(rbAttemptBar) and (bar_index - rbAttemptBar >= 1)
            rbPending  := true
            rbDir      := rbAttemptDir
            rbStartBar := rbAttemptBar
            rbOldLow   := rbAttOldLow
            rbOldHigh  := rbAttOldHigh
            rbOldMid   := rbAttOldMid
            rbNewLow   := na
            rbNewHigh  := na
            rbNewMid   := na

            rbAttempt    := false
            rbAttemptDir := 0
            rbAttemptBar := na
            rbAttOldLow  := na
            rbAttOldHigh := na
            rbAttOldMid  := na

// Step 2: confirm value migration -> new balance outside old range
// Confirm conditions (must persist for rbConfirmBars window):
// - balance width small
// - EMA separation small
// - location: majority outside old range (using closes)
rbBarsSinceStart = rbPending ? (bar_index - rbStartBar) : 0

rbBalWidthOk = (raWidth <= atr * rbBalMaxWidth_ATR) and (math.abs(emaFast - emaSlow) <= atr * rbBalMaxEMASep_ATR)

// Outside-old-range location check
outsideUp   = not na(rbOldHigh) and (close > rbOldHigh)
outsideDown = not na(rbOldLow)  and (close < rbOldLow)
insideOld   = not na(rbOldHigh) and not na(rbOldLow) and (close <= rbOldHigh) and (close >= rbOldLow)

// For confirmation, require last rbConfirmBars closes are mostly outside in rbDir
outsideSeries = rbDir == 1 ? (close > rbOldHigh) : (close < rbOldLow)
// ta.sum length accepts an input int; this is safe.
outsideSeriesF = outsideSeries ? 1.0 : 0.0
outsideSMA     = ta.sma(outsideSeriesF, rbConfirmBars)

outsideCount = (rbPending and (rbBarsSinceStart >= rbConfirmBars))
     ? int(outsideSMA * rbConfirmBars)
     : 0


rbMinOutside = int(math.floor(rbConfirmBars * 0.6))
rbLocationOk = rbPending and (rbBarsSinceStart >= rbConfirmBars) and (outsideCount >= rbMinOutside)

if rbPending and (rbBarsSinceStart >= rbConfirmBars) and rbBalWidthOk and rbLocationOk
    rbActive   := true
    rbPending  := false
    // Freeze new balance snapshot
    rbNewLow   := rollLow
    rbNewHigh  := rollHigh
    rbNewMid   := rollMid

// If pending and price fully reverts into old range with 2 closes, abandon RB pending (no migration)
rbRevertPending = rbPending and not na(rbOldLow) and not na(rbOldHigh) and (close >= rbOldLow) and (close <= rbOldHigh) and (close[1] >= rbOldLow) and (close[1] <= rbOldHigh)
if rbRevertPending
    rbPending := false
    rbDir := 0
    rbStartBar := na
    rbOldLow := na
    rbOldHigh := na
    rbOldMid := na

// Range-B resolution tree (active state):
// (a) Reversion acceptance back into old range => Range-A
rbRevertAccept = rbActive and not na(rbOldLow) and not na(rbOldHigh) and (close >= rbOldLow) and (close <= rbOldHigh) and (close[1] >= rbOldLow) and (close[1] <= rbOldHigh)

// (b) Acceptance upward from new balance => Bull (requires HTF ON)
rbBullAccept = rbActive and (rbDir == 1) and htfBullOk and not na(rbNewHigh) and (close > rbNewHigh) and (close[1] > rbNewHigh)

// (c) Acceptance down from new balance => Bear (requires HTF OFF)
rbBearAccept = rbActive and (rbDir == -1) and (not htfTrendOk) and not na(rbNewLow) and (close < rbNewLow) and (close[1] < rbNewLow)

//====================================================
// Router (flat regime selection + forced-mode downgrades)
//====================================================
var Mode mode = Mode.Wait
prevMode = mode

// Forced mode overrides router while flat (after time-stop downgrades)
if forcedActive
    mode := forcedMode
else
    // Bear is an OVERLAY (global risk regime), not a trade-engine mode.
    // It can be "active" while flat (lockout) and while in position (kill-switch).
    bearOverlay = bearActive

    // Keep the legacy naming for readability (flat-only overlay state)
    isBearFlat = (not inPos) and bearOverlay


    // Bull acceptance-truth state exists regardless of HTF.
    // HTF is only a veto for selecting Bull mode.
    bullTruthLive = (not inPos) and (pendingBull or bullArmed or bullPBSeen)
    bullSetupLive = bullTruthLive and htfBullOk and bullLocalTrendOk and (not adxGateBullMode or adxBullRegimeOk)

    // Range-B regime when RB attempt/pending/active (value migration risk starts at attempt)
    isRangeBFlat = (not inPos) and (rbPending or rbActive)

    // Range-A regime when HTF OFF and we have a valid RA context window
    // Must match raEntryOk's time window (raDiscRecent) so router doesn't suppress valid entries.
    isRangeAFlat = (not inPos) and htfOffForRA and (not bearOverlay) and (raInBalance or raBalSnapOk) and raDiscRecent


    if bullSetupLive
        mode := Mode.Bull
    else if isRangeBFlat
        mode := Mode.RangeB
    else if isRangeAFlat
        mode := Mode.RangeA
    else
    // When bear overlay is active while flat, we still do NOT allow entries.
    // Using WAIT here keeps engines off without pretending Bear is a trade mode.
        mode := Mode.Wait


//====================================================
// Raw regime observability (independent of selected mode)
//====================================================
raExistsRaw = (not inPos) and htfOffForRA and raInBalance
rbExistsRaw = (not inPos) and (rbPending or rbActive)


// Transition events (mandatory)
enteredBull   = (mode == Mode.Bull)   and (prevMode != Mode.Bull)
enteredRangeA = (mode == Mode.RangeA) and (prevMode != Mode.RangeA)
enteredRangeB = (mode == Mode.RangeB) and (prevMode != Mode.RangeB)
enteredWait   = (mode == Mode.Wait)   and (prevMode != Mode.Wait)

// Transition resets (Q3 fix):
// Do NOT wipe Bull acceptance-truth state on transitions.
// Acceptance truth is close-based and HTF-independent.
// HTF is a veto for Bull mode/entries only.
// Bull truth is cleared only by: bullLostAcceptance, bullPendingExpired, bullSetupExpired, or after entry consumption.
if enteredWait or enteredRangeA or enteredRangeB
    // no-op (intentionally)
    na


//====================================================
// Bear SHORT (Commit S1) — v1.3 only: accept-down -> retest -> breakdown
//====================================================

// Retest latch: after bearActive, wait for a pullback near bearBreakLvl (no chase)
if bearActive and bearShortOn and (not inPos) and not na(bearBreakLvl)
    float zTop = bearBreakLvl + atr * bearPB_MaxPop_ATR
    bool poppedToZone = (high >= bearBreakLvl) and (high <= zTop)
    bool closeHolds   = (close <= bearBreakLvl - atr * bearPB_CloseUnder_ATR)

    if (not bearPBSeen) and poppedToZone and closeHolds
        bearPBSeen := true
        if barstate.isconfirmed
            c_bearPBSeen += 1
        bearPBBar  := bar_index

// Expire stale retest latch
bearPBExpired = bearPBSeen and (not inPos) and (not na(bearPBBar)) and ((bar_index - bearPBBar) > bearArmMaxBars)
if bearPBExpired
    bearPBSeen := false
    bearPBBar  := na

// Breakdown trigger: bearish candle breaks micro-low and closes below bearBreakLvl
bearBreakLB = ta.lowest(low[1], bearBreakLookback)

bearShortBreakdownNow =
     bearActive and bearShortOn and (not inPos) and bearPBSeen and
     (adx >= bearAdxMin) and
     (close < bearBreakLvl) and (close < open) and (bodyPct >= bearMinBodyPct) and
     (close < bearBreakLB) and
     bearShortADXOk and bearCloseNearLowOk

if barstate.isconfirmed and bearShortBreakdownNow
    c_bearBreakSig += 1

//====================================================
// Range-B SHORT (Commit S2) — down re-anchor value-failure short
//====================================================

// Define RB value boundary (use rbNewMid if available; fallback to rollMid)
rbSValueNow = not na(rbNewMid) ? rbNewMid : rollMid

// Only allow RB short when RB is ACTIVE and direction is DOWN re-anchor
rbSContext = rbActive and (rbDir == -1) and ((not htfTrendOk) and (not htfNeutral))

// Retest latch: pullback into value boundary, then hold (no chase)
if rbSContext and rbShortOn and (not inPos) and (not bearActive) and (not pendingBear)
    rbSValue := rbSValueNow

    float zTop = rbSValue + atr * rbS_PB_MaxPop_ATR
    bool poppedToValueZone = (high >= rbSValue) and (high <= zTop)
    bool closeHoldsValue   = (close <= rbSValue + atr * rbS_Hold_ATR)

    if (not rbSPBSeen) and poppedToValueZone and closeHoldsValue
        rbSPBSeen := true
        rbSPBBar  := bar_index

// Expire stale retest latch
rbSPBExpired = rbSPBSeen and (not inPos) and (not na(rbSPBBar)) and ((bar_index - rbSPBBar) > rbS_ArmMaxBars)
if rbSPBExpired
    rbSPBSeen := false
    rbSPBBar  := na
    rbSValue  := na

// Rejection trigger: bearish candle closes back below value boundary and breaks micro-low
rbSBreakLB = ta.lowest(low[1], rbS_BreakLookback)

rbShortRejectionNow =
     rbSContext and rbShortOn and (not inPos) and rbSPBSeen and not na(rbSValue) and
     (close < (rbSValue - atr * bufATR)) and (close < open) and (bodyPct >= rbS_MinBodyPct) and
     (close < rbSBreakLB) and
     rbShortADXOk and rbCloseNearLowOk


//====================================================
// Entries (mutually exclusive while flat)
//====================================================
//====================================================
// Bull continuation ADD entry (in-position pyramiding)
//====================================================
bullInPos = inPos and (posTag == "BULL")

// Spacing
bullAddSpacingOk = bullInPos and (na(bullLastAddBar) or (bar_index - bullLastAddBar >= bullAddSpacingBars))

// Not extended filter (avoid adding too late)
bullExtNow = (close - emaFast) / atr
bullNotExtendedOk = bullInPos and (bullExtNow <= bullAddMaxExt_ATR)

// Pullback definition: low dips to/under EMAfast but not too deep
bullAddPB = bullInPos and (low <= emaFast) and (low >= emaFast - atr * bullAddDip_ATR)

// Reclaim candle definition: bullish, closes back above EMAfast, decent body, breaks micro-high
bullAddBreak = ta.highest(high[1], bullAddBreakLB)
bullAddCloseTopOk = (rng > 0) and ((close - low) / rng >= bullAddCloseNearHigh)
bullAddReclaim =
     bullAddPB and (close > emaFast) and (close > open) and (bodyPct >= bullAddBodyPct) and
     ( (close > bullAddBreak) or bullAddCloseTopOk )

// Optional safety: only allow adds after TP1
bullMFE_ATR = bullInPos ? ((tradeHi - strategy.position_avg_price) / atr) : 0.0
bullAddProofOk = (bullMFE_ATR >= bullAddProofMFE_ATR)
bullAddTP1Ok = (not bullAddAfterTP1Only) or bullTP1Done or bullAddProofOk
// Must make AND ACCEPT above the prior add reference (prevents chop-ladder adds)
bullAddNewHighOk =
     bullInPos and (
         na(bullAddRefHi) or
         (high > bullAddRefHi)
     )

// Final add condition
bullAddTrailOk = (not bullAddRequireTrailArmed) or bullTrailArmed

adxAddRising = chgN(adx, adxSlopeBars) > 0

bullAddEnter =
     bullAddOn and bullAddSpacingOk and bullNotExtendedOk and bullAddReclaim and
     adxBullAddOk and (not adxBullAddSlopeRequired or adxAddRising) and bullAddTP1Ok and
     bullAddTrailOk and
     bullAddNewHighOk and
     htfBullOk and
     (not bearActive) and (not pendingBear) and
     (close > emaSlow)



if barstate.isconfirmed and bullInPos and bullAddOn
    if bullAddPB
        c_addPB += 1

    // Only evaluate "blocks" when we are actually attempting: RECLAIM happened
    if bullAddReclaim
        if not bullAddTP1Ok
            c_addBlkTP1 += 1
        if not adxBullAddOk
            c_addBlkADX += 1
        if adxBullAddSlopeRequired and (not adxAddRising)
            c_addBlkSlope += 1
        if not bullNotExtendedOk
            c_addBlkExt += 1
        if not bullAddSpacingOk
            c_addBlkSpc += 1
        if not bullAddNewHighOk
            c_addBlkNH += 1
        if not htfBullOk
            c_addBlkHTF += 1
        if not (close > emaSlow)
            c_addBlkSlow += 1
        if not bullAddTrailOk
            c_addBlkTrail += 1

    if bullAddReclaim
        c_addReclaim += 1


//====================================================
// L2 trackers update (cheap)
//====================================================

// "Impulse" definition (cheap, structure-ish): big range vs ATR + meaningful body
l2_rangeATR = (atr > 0) ? (rng / atr) : na
l2_impulseNow = (not na(l2_rangeATR)) and (l2_rangeATR >= 1.20) and (bodyPct >= 0.50)

if barstate.isconfirmed and l2_impulseNow
    l2_lastImpulseBar := bar_index

// Acceptance events (close-based truth)
l2_acceptNow =
     (bullAcceptUp) or (raAccept2Cl) or (upAcceptNow) or (downAcceptNow) or (bearAcceptOk)

if barstate.isconfirmed and l2_acceptNow
    l2_lastAcceptBar := bar_index

// Reclaim events (close-based)
l2_reclaimNow =
     (bullReclaimNow) or (raReclaimOk) or (bearReclaimOk)

if barstate.isconfirmed and l2_reclaimNow
    l2_lastReclaimBar := bar_index


//====================================================
// Scoring (simple, explicit, per-mode; logged at entry)
//====================================================


//====================================================
// Entry score gate (optional, execution-layer filter)
//====================================================

scoreBull() =>
    int s = 0
    s += htfTrendOk ? 1 : 0
    s += bullAcceptUp or bullArmed or bullPBSeen ? 1 : 0
    s += bullPBSeen ? 1 : 0
    s += (bodyPct >= bullMinBodyPct_T) ? 1 : 0
    s

scoreRA() =>
    int s = 0
    s += raInBalance ? 1 : 0
    s += raDiscRecent ? 1 : 0
    s += raReclaimOk ? 1 : 0
    s += raRsiOk ? 1 : 0
    s += raStructOk ? 1 : 0
    s

scoreRB() =>
    int s = 0
    s += (rbPending or rbActive) ? 1 : 0
    s += rbBalWidthOk ? 1 : 0
    s += rbLocationOk ? 1 : 0
    s += (rbDir != 0) ? 1 : 0
    s

scoreBear() =>
    int s = 0
    s += (not htfTrendOk) ? 1 : 0
    s += pendingBear ? 1 : 0
    s += bearActive ? 1 : 0
    s

scoreGateOk(_mode) =>
    minEntryScore <= 0 ? true :
     _mode == Mode.Bull   ? (scoreBull() >= minEntryScore) :
     _mode == Mode.RangeA ? (scoreRA()   >= minEntryScore) :
     true


//====================================================
// LAYER 2 — Window logs (±N bars around events) to Pine Logs
//====================================================

// Header once
// L2 export: one-time CSV header (emitted on first actual row)

// CSV safety: any string field must not contain commas
l2_sanitize(string s) =>
    str.replace_all(s, ",", ";")

// ===== CHUNK 1 END =====



// ===== CHUNK 2 START =====

// ---- Bitmask for blockedBy (cheap + explicit) ----
const int BLK_HTF      = 1
const int BLK_ADX      = 2
const int BLK_SPACING  = 4
const int BLK_EXT      = 8
const int BLK_WINDOW   = 16
const int BLK_SCORE    = 32
const int BLK_BEAR     = 64
const int BLK_OTHER    = 128
// PB veto bits (PBDEC veto mask)
const int PBV_TOUCH       = 1
const int PBV_HHPROOF     = 2
const int PBV_SCORE       = 4
const int PBV_STALL       = 8
const int PBV_EXHAUST     = 16
const int PBV_LATE        = 32
const int PBV_LIFECYCLE   = 64
const int PBV_LATE_STALL  = 128
const int PBV_AGE         = 256
const int PBV_FRESH       = 512
const int PBV_EXPAGE = 1024
const int PBV_IMPULSE_CHASE = 2048
const int PBV_LATE_FAIL = 4096
const int PBV_RETRY_CHASE = 8192
const int PBV_EARLY_ASSUME = 32768



// ---- Rolling buffers (keep last l2WindowBars bars of features) ----
var array<int>   l2_bi   = array.new_int()
var array<int>   l2_t    = array.new_int()

var array<float> l2_o    = array.new_float()
var array<float> l2_h    = array.new_float()
var array<float> l2_l    = array.new_float()
var array<float> l2_c    = array.new_float()
var array<float> l2_v    = array.new_float()

var array<float> l2_atrA = array.new_float()
var array<float> l2_body = array.new_float()
var array<float> l2_uw   = array.new_float()
var array<float> l2_lw   = array.new_float()
var array<float> l2_cloc = array.new_float()
var array<float> l2_rngA = array.new_float()

var array<float> l2_dDec = array.new_float()
var array<float> l2_dEF  = array.new_float()
var array<float> l2_dES  = array.new_float()

var array<int>   l2_abv  = array.new_int()
var array<int>   l2_blw  = array.new_int()

var array<int>   l2_pbz  = array.new_int()
var array<int>   l2_comp = array.new_int()
var array<int>   l2_ovc  = array.new_int()

var array<int>   l2_vflag= array.new_int()
var array<float> l2_rwid = array.new_float()

var array<int>   l2_bsi  = array.new_int()
var array<int>   l2_bsa  = array.new_int()
var array<int>   l2_bsr  = array.new_int()

var array<string> l2_mode = array.new_string()
var array<int>    l2_msc  = array.new_int()

// ---- NEW: extra L2 fields (per-bar) ----
var array<float> l2_emaF  = array.new_float()
var array<float> l2_emaS  = array.new_float()
var array<float> l2_decL  = array.new_float()
var array<float> l2_decH  = array.new_float()
var array<float> l2_decM  = array.new_float()

var array<int> l2_htfOn = array.new_int()
var array<int> l2_htfNe = array.new_int()

var array<int> l2_sb = array.new_int()   // START_BULL event on this bar
var array<int> l2_eb = array.new_int()   // END_BULL event on this bar

var array<float> l2_adx  = array.new_float()
var array<float> l2_adxS = array.new_float()


// Keep size capped (past window only)
l2_cap = l2WindowBars

// ---- Helper: compact position state ----
posStateStr() =>
    // 0 flat, +L size, -S size (rounded)
    if strategy.position_size == 0
        "FLAT"
    else
        strategy.position_size > 0 ? ("L:" + str.tostring(math.round(strategy.position_size))) : ("S:" + str.tostring(math.round(math.abs(strategy.position_size))))

// ---- Helper: vol flag (−1 contraction, 0 neutral, +1 expansion) ----
l2_atrBase = ta.sma(atr, l2VolN)
l2_volFlag =
     na(l2_atrBase) ? 0 :
     atr < l2_atrBase * 0.90 ? -1 :
     atr > l2_atrBase * 1.10 ?  1 : 0

// ---- Helper: range width in ATR over last N ----
l2_hiN = ta.highest(high, l2RangeN)
l2_loN = ta.lowest(low,  l2RangeN)

l2_rangeWidthATR = (atr > 0)
     ? ((l2_hiN - l2_loN) / atr)
     : na


// ---- Helper: overlap count over last N (cheap overlap definition) ----
l2_overlaps = (low <= high[1]) and (high >= low[1])
l2_overlapF   = l2_overlaps ? 1.0 : 0.0
l2_overlapSMA = ta.sma(l2_overlapF, l2OverlapN)

l2_overlapCnt = int(l2_overlapSMA * l2OverlapN)


// Compression flag (tunable heuristic)
l2_inCompression = (l2_overlapCnt >= int(math.floor(l2OverlapN * 0.60))) ? 1 : 0

// ---- Helper: PB zone flag (Bull PB zone only; cheap) ----
int l2_inPBZone =
     (bullArmed and not na(bullLevel) and
      (low <= (bullLevel + atr * bullPB_ATR)) and
      (low >= (bullLevel - atr * bullPB_MaxDip_ATR))) ? 1 : 0

// ---- Helper: dist to decision level in ATR (closest edge) ----
l2_distDecATR = (atr > 0) ? (math.min(math.abs(close - decHigh), math.abs(close - decLow)) / atr) : na

// ---- Helper: above/below decision edges ----
l2_aboveDec = close > decHigh ? 1 : 0
l2_belowDec = close < decLow  ? 1 : 0

// ---- Mode score snapshot (cheap) ----
l2_modeScoreNow =
     mode == Mode.Bull   ? scoreBull() :
     mode == Mode.RangeA ? scoreRA()   :
     mode == Mode.RangeB ? scoreRB()   : 0

// ---- Bars-since trackers (safe ints) ----
l2_barsSince(_bar) =>
    na(_bar) ? 999999 : (bar_index - _bar)

// ---- Update rolling buffers ON CONFIRMED bars ----
l2_pushBar_impl() =>
    if barstate.isconfirmed
        // wick %s
        float _rng = math.max(high - low, syminfo.mintick)
        float _body = math.abs(close - open) / _rng
        float _uw = (high - math.max(open, close)) / _rng
        float _lw = (math.min(open, close) - low) / _rng

        // distances in ATR
        float _dEF = atr > 0 ? math.abs(close - emaFast) / atr : na
        float _dES = atr > 0 ? math.abs(close - emaSlow) / atr : na

        // push all
        array.push(l2_bi, bar_index)
        array.push(l2_t, time)

        array.push(l2_o, open)
        array.push(l2_h, high)
        array.push(l2_l, low)
        array.push(l2_c, close)
        array.push(l2_v, volume)

        array.push(l2_atrA, atr)
        array.push(l2_body, _body)
        array.push(l2_uw, _uw)
        array.push(l2_lw, _lw)
        array.push(l2_cloc, closeLoc)
        array.push(l2_rngA, (atr > 0) ? (_rng / atr) : na)

        array.push(l2_dDec, l2_distDecATR)
        array.push(l2_dEF, _dEF)
        array.push(l2_dES, _dES)

        array.push(l2_abv, l2_aboveDec)
        array.push(l2_blw, l2_belowDec)

        array.push(l2_pbz, l2_inPBZone)
        array.push(l2_comp, l2_inCompression)
        array.push(l2_ovc, l2_overlapCnt)

        array.push(l2_vflag, l2_volFlag)
        array.push(l2_rwid, l2_rangeWidthATR)

        array.push(l2_bsi, l2_barsSince(l2_lastImpulseBar))
        array.push(l2_bsa, l2_barsSince(l2_lastAcceptBar))
        array.push(l2_bsr, l2_barsSince(l2_lastReclaimBar))

        array.push(l2_mode, modeToStr(mode))
        array.push(l2_msc, l2_modeScoreNow)

        // ---- NEW fields push ----
        array.push(l2_emaF, emaFast)
        array.push(l2_emaS, emaSlow)

        array.push(l2_decL, decLow)
        array.push(l2_decH, decHigh)
        float _decMid = (decLow + decHigh) * 0.5
        array.push(l2_decM, _decMid)

        array.push(l2_htfOn, htfOnNow ? 1 : 0)
        array.push(l2_htfNe, htfNeutral ? 1 : 0)

        // START/END BULL flags (event on this bar)
        bool _sbNow = bullAcceptUp
        bool _ebNow = bullLostAcceptance
        array.push(l2_sb, _sbNow ? 1 : 0)
        array.push(l2_eb, _ebNow ? 1 : 0)

        // ADX + slope (optional but cheap)
        float _adxS = adxSlopeNow
        array.push(l2_adx, adx)
        array.push(l2_adxS, _adxS)


        // cap
        while array.size(l2_bi) > l2_cap
            array.shift(l2_bi)
            array.shift(l2_t)

            array.shift(l2_o)
            array.shift(l2_h)
            array.shift(l2_l)
            array.shift(l2_c)
            array.shift(l2_v)

            array.shift(l2_atrA)
            array.shift(l2_body)
            array.shift(l2_uw)
            array.shift(l2_lw)
            array.shift(l2_cloc)
            array.shift(l2_rngA)

            array.shift(l2_dDec)
            array.shift(l2_dEF)
            array.shift(l2_dES)

            array.shift(l2_abv)
            array.shift(l2_blw)

            array.shift(l2_pbz)
            array.shift(l2_comp)
            array.shift(l2_ovc)

            array.shift(l2_vflag)
            array.shift(l2_rwid)

            array.shift(l2_bsi)
            array.shift(l2_bsa)
            array.shift(l2_bsr)

            array.shift(l2_mode)
            array.shift(l2_msc)

            // ---- NEW fields shift ----
            array.shift(l2_emaF)
            array.shift(l2_emaS)

            array.shift(l2_decL)
            array.shift(l2_decH)
            array.shift(l2_decM)

            array.shift(l2_htfOn)
            array.shift(l2_htfNe)

            array.shift(l2_sb)
            array.shift(l2_eb)

            array.shift(l2_adx)
            array.shift(l2_adxS)


// ---- Active window state (one at a time) ----
var int    L2_eventId      = 0
var bool   L2_active       = false
var int    L2_evtBar       = na
var string L2_evtType      = ""
var string L2_exitReason   = ""
var int    L2_blockedMask  = 0
var bool   L2_isEntryEvt   = false
var bool   L2_isExitEvt    = false
var bool   L2_isCandEvt    = false
var int    L2_fwdLeft      = 0
// ---- PBDEC event fields (event-level; printed only when evtType starts with PBDEC_) ----
var int L2_pbAgeBars      = na
var int L2_pbImpAgeBars   = na
var int L2_pbFreshLateOk  = na   // 0/1
var int L2_pbFreshVeto    = na   // 0/1
var int L2_pbEnterExec    = na   // 0/1
var int L2_pbVetoMask     = na   // PB-specific veto bitmask
var int L2_pbExpAgeBars = na
var int L2_pbExpAgeVeto = na
var int L2_pbLateVeto        = na   // 0/1
var int L2_pbLifecycleVeto   = na   // 0/1
var int L2_pbAgeVeto         = na   // 0/1
var int L2_pbFreshMinAge     = na   // int
var int L2_pbMajorImpulseNow = na   // 0/1
var int L2_pbLastMajorImpBar = na   // bar_index
var int    L2_dropCnt      = 0

var bool l2HeaderDone = false

// --- L2: BEAR reclaim telemetry (order-safe; no behavior change) ---
int   L2_bearBarsIn = (inPos and (posTag == "BEAR") and not na(lastEntryBar)) ? (bar_index - lastEntryBar) : 0

float L2_bearMFEpct = (inPos and (posTag == "BEAR") and strategy.position_avg_price > 0) ?
     100.0 * (strategy.position_avg_price - tradeLo) / strategy.position_avg_price : na

float L2_bearMAEpct = (inPos and (posTag == "BEAR") and strategy.position_avg_price > 0) ?
     100.0 * (tradeHi - strategy.position_avg_price) / strategy.position_avg_price : na

// Keep this a pure "read" expression; DO NOT introduce new logic here.
float L2_bearReclLvlEff = bearReclLvl

if exportL2 and not l2HeaderDone and barstate.isconfirmed
    log.info(
         "runId,tf,scriptVer,coin,eventId,evtType,evtBar,rel," +
         "o,h,l,c,v,atrA,body,uw,lw,cloc,rngA," +
         "dDec,dEF,dES,abv,blw,pbz,comp,ovc,vflag,rwid," +
         "bsi,bsa,bsr,mode,msc," +
         "emaFast,emaSlow,decLow,decHigh,decMid," +
         "htfOn,htfNeutral,startBull,endBull," +
         "adx,adxSlope," +
         "isEntry,isExit,exitReason,isCand,blkMask,posTag,posState," +
         "pbAgeBars,pbImpAgeBars,pbFreshLateOk,pbFreshVeto,pbEnterExec,pbVetoMask," +
         "pbExpAgeBars,pbExpAgeVeto,pbLateVeto,pbLifecycleVeto,pbAgeVeto,pbFreshMinAge,pbMajorImpulseNow,pbLastMajorImpulseBar," +
         "bearReclLvl,bearInvNeed2Cl,bearReclaimCnt,bearTP0Done,bearTP1Done,bearBarsIn,bearMFEpct,bearMAEpct"
    )


l2HeaderDone := true

// ---- Emit one row (from buffer index) ----
l2_emitRow(_idx, _rel, _isEntry, _isExit, _exitReason, _isCand, _blkMask) =>

    // sanitize string fields that may contain commas
    string coin     = l2_sanitize(syminfo.ticker)
    string evtType  = l2_sanitize(L2_evtType)
    string modeS    = l2_sanitize(array.get(l2_mode, _idx))
    string exitR    = l2_sanitize(_exitReason)
    string tagS     = l2_sanitize(posTagToLogMode(posTag))
    string posStS   = l2_sanitize(posStateStr())
    // ---- L2 BEAR telemetry (local, order-safe) ----
    float l2_bearReclLvl = bearReclLvl
    int   l2_bearInv2Cl  = bearInvNeed2Cl ? 1 : 0
    int   l2_bearReclCnt = bearReclaimCloseCnt
    int   l2_bearTP0     = bearTP0Done ? 1 : 0
    int   l2_bearTP1     = bearTP1Done ? 1 : 0
    int l2_bearBarsIn = (inPos and (posTag == "BEAR") and not na(lastEntryBar)) ? (bar_index - lastEntryBar) : 0
    float l2_bearMFEpct = (inPos and (posTag == "BEAR") and strategy.position_avg_price > 0) ? 100.0 * (strategy.position_avg_price - tradeLo) / strategy.position_avg_price : na
    float l2_bearMAEpct = (inPos and (posTag == "BEAR") and strategy.position_avg_price > 0) ? 100.0 * (tradeHi - strategy.position_avg_price) / strategy.position_avg_price : na
    // PBDEC fields (only populated for PB decision events; blank otherwise)
    bool isPBDec = str.startswith(evtType, "PBDEC_")
    string pbAgeS      = isPBDec ? str.tostring(L2_pbAgeBars) : ""
    string pbImpAgeS   = isPBDec ? str.tostring(L2_pbImpAgeBars) : ""
    string pbLateOkS   = isPBDec ? str.tostring(L2_pbFreshLateOk) : ""
    string pbFreshS    = isPBDec ? str.tostring(L2_pbFreshVeto) : ""
    string pbExecS     = isPBDec ? str.tostring(L2_pbEnterExec) : ""
    string pbMaskS     = isPBDec ? str.tostring(L2_pbVetoMask) : ""
    string pbExpAgeS   = isPBDec ? str.tostring(L2_pbExpAgeBars) : ""
    string pbExpVetoS  = isPBDec ? str.tostring(L2_pbExpAgeVeto) : ""
    string pbLateVetoS = isPBDec ? str.tostring(L2_pbLateVeto) : ""
    string pbLifeVetoS = isPBDec ? str.tostring(L2_pbLifecycleVeto) : ""
    string pbAgeVetoS  = isPBDec ? str.tostring(L2_pbAgeVeto) : ""
    string pbMinAgeS   = isPBDec ? str.tostring(L2_pbFreshMinAge) : ""
    string pbMajNowS   = isPBDec ? str.tostring(L2_pbMajorImpulseNow) : ""
    string pbLastImpS  = isPBDec ? str.tostring(L2_pbLastMajorImpBar) : ""


    int ebar = L2_evtBar
    log.info(
      L1_runId + "," +
      L1_tf + "," +
      L1_scriptVer + "," +
      coin + "," +
      str.tostring(L2_eventId) + "," +
      evtType + "," +
      str.tostring(ebar) + "," +
      str.tostring(_rel) + "," +
      str.tostring(array.get(l2_o, _idx)) + "," +
      str.tostring(array.get(l2_h, _idx)) + "," +
      str.tostring(array.get(l2_l, _idx)) + "," +
      str.tostring(array.get(l2_c, _idx)) + "," +
      str.tostring(array.get(l2_v, _idx)) + "," +
      str.tostring(array.get(l2_atrA, _idx)) + "," +
      str.tostring(array.get(l2_body, _idx)) + "," +
      str.tostring(array.get(l2_uw, _idx)) + "," +
      str.tostring(array.get(l2_lw, _idx)) + "," +
      str.tostring(array.get(l2_cloc, _idx)) + "," +
      str.tostring(array.get(l2_rngA, _idx)) + "," +
      str.tostring(array.get(l2_dDec, _idx)) + "," +
      str.tostring(array.get(l2_dEF, _idx)) + "," +
      str.tostring(array.get(l2_dES, _idx)) + "," +
      str.tostring(array.get(l2_abv, _idx)) + "," +
      str.tostring(array.get(l2_blw, _idx)) + "," +
      str.tostring(array.get(l2_pbz, _idx)) + "," +
      str.tostring(array.get(l2_comp, _idx)) + "," +
      str.tostring(array.get(l2_ovc, _idx)) + "," +
      str.tostring(array.get(l2_vflag, _idx)) + "," +
      str.tostring(array.get(l2_rwid, _idx)) + "," +
      str.tostring(array.get(l2_bsi, _idx)) + "," +
      str.tostring(array.get(l2_bsa, _idx)) + "," +
      str.tostring(array.get(l2_bsr, _idx)) + "," +
      modeS + "," +
      str.tostring(array.get(l2_msc, _idx)) + "," +
      str.tostring(array.get(l2_emaF, _idx)) + "," +
      str.tostring(array.get(l2_emaS, _idx)) + "," +
      str.tostring(array.get(l2_decL, _idx)) + "," +
      str.tostring(array.get(l2_decH, _idx)) + "," +
      str.tostring(array.get(l2_decM, _idx)) + "," +
      str.tostring(array.get(l2_htfOn, _idx)) + "," +
      str.tostring(array.get(l2_htfNe, _idx)) + "," +
      str.tostring(array.get(l2_sb, _idx)) + "," +
      str.tostring(array.get(l2_eb, _idx)) + "," +
      str.tostring(array.get(l2_adx, _idx)) + "," +
      str.tostring(array.get(l2_adxS, _idx)) + "," +
      str.tostring(_isEntry ? 1 : 0) + "," +
      str.tostring(_isExit  ? 1 : 0) + "," +
      exitR + "," +
      str.tostring(_isCand ? 1 : 0) + "," +
      str.tostring(_blkMask) + "," +
      tagS + "," +
      posStS + "," +
      pbAgeS + "," +
      pbImpAgeS + "," +
      pbLateOkS + "," +
      pbFreshS + "," +
      pbExecS + "," +
      pbMaskS + "," +
      pbExpAgeS + "," +
      pbExpVetoS + "," +
      pbLateVetoS + "," +
      pbLifeVetoS + "," +
      pbAgeVetoS + "," +
      pbMinAgeS + "," +
      pbMajNowS + "," +
      pbAgeVetoS + "," + 
      pbMinAgeS + "," + 
      pbMajNowS + "," + 
      pbLastImpS + "," + 
      str.tostring(l2_bearReclLvl) + "," + 
      str.tostring(l2_bearInv2Cl) + "," + 
      str.tostring(l2_bearReclCnt) + "," + 
      str.tostring(l2_bearTP0) + "," + 
      str.tostring(l2_bearTP1) + "," + 
      str.tostring(l2_bearBarsIn) + "," + 
      str.tostring(l2_bearMFEpct) + "," + 
      str.tostring(l2_bearMAEpct) + "," +
      str.tostring(bearReclLvl) + "," + 
      str.tostring(bearInvNeed2Cl ? 1 : 0) + "," + 
      str.tostring(bearReclaimCloseCnt) + "," + 
      str.tostring(bearTP0Done ? 1 : 0) + "," + 
      str.tostring(bearTP1Done ? 1 : 0) + "," + 
      str.tostring(L2_bearReclLvlEff)
    )

// ---- Forward emission (next +N bars) ----
if exportL2 and barstate.isconfirmed and L2_active
    // emit only for bars AFTER event bar
    if bar_index > L2_evtBar
        int sz2 = array.size(l2_bi)
        if sz2 > 0
            int curIdx2 = sz2 - 1
            int rel = bar_index - L2_evtBar
            l2_emitRow(curIdx2, rel, false, false, "", false, 0)
        L2_fwdLeft -= 1
        if L2_fwdLeft <= 0
            L2_active := false
            L2_evtBar := na
            L2_evtType := ""
            L2_exitReason := ""
            L2_blockedMask := 0
            L2_isEntryEvt := false
            L2_isExitEvt := false
            L2_isCandEvt := false
            L2_fwdLeft := 0
     
// Hard mutual exclusivity: if START is valid, PB is forbidden; if PB is valid, START is forbidden.
// Step 3: strict mutual exclusivity (START has priority over PB entry)
bullImpulseEnter =
     barstate.isconfirmed and
     (not inPos) and (mode == Mode.Bull) and
     scoreGateOk(Mode.Bull) and
     bullStartEntry and
     (not bullPBSeen) and
     (not bullImpulseDone) and
     bullLocalTrendOk and
     htfBullOk and bullStartADXok

bullCompEnter = barstate.isconfirmed and (not inPos) and (mode == Mode.Bull) and scoreGateOk(Mode.Bull) and
     bullAcceptCompression and bullCompNotChase and
     (not bullStartEntry) and (not bullImpulseDone) and
     bullLocalTrendOk and htfBullOk and adxBullExecOk and (not bullUseDMI or (pdi > mdi))

// --- PB Expansion-Age veto (NEW) ---
// ExpansionAge = bars since last bull-leg structural expansion (new high)
int bullPBExpAgeBars = na(bullLastExpansionBar) ? 999999 : (bar_index - bullLastExpansionBar)

// Candidate: late-expansion-age + weak entry candle veto
// VETO if ExpAge >= N AND bodyPct <= X
bool bullPBLateExpAgeBodyVeto = bullPBUseLateExpAgeBodyVeto and (bullPBExpAgeBars >= bullPBLateExpAgeBars_VetoN) and (bodyPct <= bullPBLateBodyPct_VetoMax)

bullPBEnter = barstate.isconfirmed and (not inPos) and (mode == Mode.Bull) and scoreGateOk(Mode.Bull) and bullPBSeen and bullReclaimNow and (not bullStartEntry) and (not bullImpulseDone) and bullLocalTrendOk and htfBullOk and (not bullUseDMI or (pdi > mdi)) and adxBullPBExecOk and (not bullPBLateExpAgeBodyVeto)

// --- PB-Count cap: compute prospective PB number for this bar ---
int bullPBCountNext = bullPBCount + (bullPBEnter ? 1 : 0)
bool bullPBLateVeto = bullPBCountNext > bullPBMaxPerBull

// Commit counter update on signal (even if veto blocks execution, we still count the attempt)
if bullPBEnter
    bullPBCount += 1


rangeAEnter = barstate.isconfirmed and (not inPos) and (mode == Mode.RangeA) and raEntryOk and scoreGateOk(Mode.RangeA)
rangeBEnter = false  // Strategy v1.0: Range-B is a NO-TRADE regime manager (value migration). It must resolve (to RA/Bull/Bear) or time-stop -> downgrade+log.

// Execute entries
entered = false
entryMode = Mode.Wait

// --- BEAR SHORT entry (v1.3 only) ---
bearReentryOk = na(lastBearShortExitBar) or (bar_index - lastBearShortExitBar >= 24)

if barstate.isconfirmed and bearReentryOk
    c_bearReentryOk += 1

bearShortEnter =
     (bearAcceptImpulseEnter) or
     (
         barstate.isconfirmed and (not inPos) and bearShortBreakdownNow and
         bearLocalDowntrendOk and (close < emaFast) and
         bearLockoutOk and bearReentryOk and shortCooldownOk and
         (
             bearAllowContinuation or
             (not bearKillUseHTFveto or htfOffForRA)
         )
     )

if bearShortEnter
    strategy.entry("SHORT", strategy.short)

    posTag := "BEAR"
    entryModeTag := "BEAR"
    // L1 pending entry (committed on actual fill)
    L1_pendDir  := "SHORT"
    L1_pendReg  := "BEAR"
    L1_pendArch := bearAcceptImpulseEnter ? "BEAR_S_ACCEPT" : "BEAR_S_BREAKDOWN"

    L1_pendEntryEngine  := "BEAR_ENTRY"
    L1_pendHtfState     := htfOnNow ? "HTF_ON" : "HTF_OFF"
    L1_pendHtfFlipEvent := htfFlipEventNow
    L1_pendLastFlipType := lastBullFlipType
    L1_pendAcceptUpCnt  := bullAcceptUpCnt
    L1_pendQualMask     := qualMask(bearActive, bearPBSeen, (not htfOnNow), bearLocalDowntrendOk)

    L1_pendMode      := modeToStr(mode)
    L1_pendModeScore := l2_modeScoreNow
    L1_pendAdx       := adx
    L1_pendAdxRising := (adxRising ? 1 : 0)

    L1_pendBodyPct   := bodyPct
    L1_pendCloseLoc  := closeLoc
    L1_pendRngAtr    := (atr > 0 ? (rng / atr) : na)

    // Distances (ATR)
    L1_pendDistEFATR := (atr > 0 ? math.abs(close - emaFast) / atr : na)
    L1_pendDistESATR := (atr > 0 ? math.abs(close - emaSlow) / atr : na)

    // Bull-level distance only meaningful for Bull, but safe for others (na if bullLevel na)
    L1_pendDistBullATR := (atr > 0 and not na(bullLevel)) ? math.abs(close - bullLevel) / atr : na

    // Timing context
    L1_pendBSI := l2_barsSince(l2_lastImpulseBar)
    L1_pendBSA := l2_barsSince(l2_lastAcceptBar)
    L1_pendBSR := l2_barsSince(l2_lastReclaimBar)


    entered := true
    entryMode := Mode.Wait  // Bear remains overlay; do not force router mode
    bearTP1Done := false 
    bearTP0Done := false 
    bearTP0Bar := na 
    bearTP0Lo := na 
    bearTP0EntryPx := na 
   
    // Consume latch
    bearPBSeen := false
    bearPBBar  := na

// --- RANGE-B SHORT entry (Commit S2) ---
rbReentryOk = na(lastRBShortExitBar) or (bar_index - lastRBShortExitBar >= 24)
rbShortEnter =
     barstate.isconfirmed and (not inPos) and rbShortRejectionNow and
     bearLocalDowntrendOk and (close < emaFast) and
     shortCooldownOk and rbReentryOk


if rbShortEnter
    strategy.entry("RB_SHORT", strategy.short)

    posTag := "RANGEB"
    entryModeTag := "RANGE-B"
    L1_pendDir  := "SHORT"
    L1_pendReg  := "RANGE-B"
    L1_pendArch := "RB_S_REJECT"

    L1_pendEntryEngine  := "RB_SHORT"
    L1_pendHtfState     := htfOnNow ? "HTF_ON" : "HTF_OFF"
    L1_pendHtfFlipEvent := htfFlipEventNow
    L1_pendLastFlipType := lastBullFlipType
    L1_pendAcceptUpCnt  := bullAcceptUpCnt
    L1_pendQualMask     := qualMask(rbActive, rbSPBSeen, (not htfOnNow), bearLocalDowntrendOk)

    L1_pendMode      := modeToStr(mode)
    L1_pendModeScore := l2_modeScoreNow
    L1_pendAdx       := adx
    L1_pendAdxRising := (adxRising ? 1 : 0)

    L1_pendBodyPct   := bodyPct
    L1_pendCloseLoc  := closeLoc
    L1_pendRngAtr    := (atr > 0 ? (rng / atr) : na)

    // Distances (ATR)
    L1_pendDistEFATR := (atr > 0 ? math.abs(close - emaFast) / atr : na)
    L1_pendDistESATR := (atr > 0 ? math.abs(close - emaSlow) / atr : na)

    // Bull-level distance only meaningful for Bull, but safe for others (na if bullLevel na)
    L1_pendDistBullATR := (atr > 0 and not na(bullLevel)) ? math.abs(close - bullLevel) / atr : na

    // Timing context
    L1_pendBSI := l2_barsSince(l2_lastImpulseBar)
    L1_pendBSA := l2_barsSince(l2_lastAcceptBar)
    L1_pendBSR := l2_barsSince(l2_lastReclaimBar)

    entered := true
    entryMode := Mode.RangeB

    // consume latch
    rbSPBSeen := false
    rbSPBBar  := na

// --- PB-Guard v2 (exhaustion micro-PB filter) ---

// Always-evaluated rolling high (for non-inPos depth calc)
float bullRecentHigh24 = ta.highest(high, 24)

// 1) Extension filter: don't PB-buy when far above EMAfast
// 2) Depth filter: require a real pullback from recent high
float bullPBDepth =
     (inPos and isLong and posTag=="BULL")
         ? (tradeHi - low)
         : (bullRecentHigh24 - low)

// Veto only: exhaustion-top micro-PB
// Extended = far above EMAfast OR far above bullLevel (EMAfast can catch up late-trend)
bool bullPBExtended =
     (atr > 0) and (
        ((close - emaFast) > (atr * bullPBMaxExtAboveEma_ATR)) or
        (not na(bullLevel) and ((close - bullLevel) > (atr * bullPBMaxAbove_ATR)))
     )

bool bullPBShallow = (atr > 0) and (bullPBDepth < (atr * bullPBMinPullback_ATR))

bool bullPBExhaustVeto = bullPBExtended and bullPBShallow

// --- PB Late-Lifecycle veto (targets “late PB near exhaustion”, not micro-PB only) ---
int bullPBAgeBars = (not na(bullStartBar)) ? (bar_index - bullStartBar) : 0
bool bullPBAgeVeto = bullPBAgeBars > bullPBMaxAgeBars 

// --- PB Freshness: MAJOR impulse age (NEW axis) ---
int pbImpLookback = 12

int bullMajorImpulseAgePrev = na(bullLastMajorImpulseBar) ? 999999 : (bar_index - bullLastMajorImpulseBar)

float pbMajorBreakLvl = ta.highest(high[1], pbImpLookback)

bool pbMajorImpulse =
     (bodyPct >= 0.70) and
     (closeLoc >= 0.80) and
     (close > pbMajorBreakLvl)

// 4) update last major impulse AFTER we captured agePrev
if pbMajorImpulse
    bullLastMajorImpulseBar := bar_index
    // NEW: a new impulse resets the retry-chase latch
if barstate.isconfirmed and pbMajorImpulse
    pbChaseFailActive := false
    pbChaseFailKey := na

// --- PB Freshness veto (Impulse-Age) (NEW) ---
// "Impulse age" = bars since the last detected impulse (from L2 state)

// "Late" should not rely only on bullStartBar, because START_BULL can re-print late and reset age.
// Treat PB as "late-eligible" if any late/lifecycle veto is active OR age is high.

// --- PB Late-Stall veto (kills late PBs even if pullback depth is real) ---
bool bullPBLateStallAge = bullPBAgeBars >= bullPBLateStallAgeBars
bool bullPBLateStall = bullLegNoNewHiStreak >= bullPBLateStallNoHHBars
bool bullPBLateStallVeto = bullPBLateStallAge and bullPBLateStall

bool bullPBLateAge = bullPBAgeBars >= bullPBLateAgeBars


bool bullPBLateExt =
     (atr > 0) and (not na(bullLevel)) and ((close - bullLevel) > (atr * bullPBLateMaxAbove_ATR))

bool bullPBLateShallow =
     (atr > 0) and (bullPBDepth < (atr * bullPBLateMinDepth_ATR))
bool bullPBLifecycleVeto = bullPBLateAge and bullPBLateExt and bullPBLateShallow
// START_BULL can reprint late and reset bullStartBar; do not rely only on bullPBAgeBars.
//bool bullPBFreshnessLateOk =
//     (bullPBAgeBars >= bullPBFreshMinAgeBars) or bullPBLateVeto or bullPBLifecycleVeto or bullPBAgeVeto

int bullMajorImpulseAgeBars = na(bullLastMajorImpulseBar) ? 999999 : (bar_index - bullLastMajorImpulseBar)

int bullPBImpulseAgeBars = bullMajorImpulseAgeBars

// --- PB Freshness "Late eligibility" (FIXED) ---
// START_BULL can reprint late and reset bullStartBar; do not rely only on bullPBAgeBars.
// LateOk should activate when PB is late by lifecycle/late/age signals.
bool bullPBFreshnessLateOk =
     (bullPBAgeBars >= bullPBFreshMinAgeBars) or
     bullPBLateVeto or
     bullPBLifecycleVeto or
     bullPBAgeVeto

bool bullPBFreshVeto = bullPBUseFreshness and bullPBFreshnessLateOk and (bullPBImpulseAgeBars > bullPBMaxImpulseAgeBars)


// We only apply this veto when PB is already "late-eligible" (same philosophy as Freshness)
bool bullPBExpAgeVeto = bullPBUseExpAge and bullPBFreshnessLateOk and (bullPBExpAgeBars > bullPBMaxExpAgeBars)

// --- PB Impulse-Chase veto (NEW) ---
// Blocks PB entries that fire on the same bar as a new major impulse while ADX slope is rising.
bool bullPBImpulseChaseVeto = pbMajorImpulse and (bullPBImpulseAgeBars == 0) and (adxSlopeNow > 0)
// NEW: latch failed PB idea only when we actually ATTEMPTED PB on the impulse bar and got impulse-chase veto
if barstate.isconfirmed and bullPBEnter and bullPBImpulseChaseVeto
    pbChaseFailActive := true
    pbChaseFailKey := bullLastMajorImpulseBar


bool bullPBRetryAfterChaseVeto = pbChaseFailActive and (bullLastMajorImpulseBar == pbChaseFailKey) and (bar_index > bullLastMajorImpulseBar)

// Touch logic: by default allow "touch" (brings PB trades back). Optional strict mode requires reclaim close.
bool bullPBTouchOk =
     (not bullPBRequireTouchEF) ? true :
     (bullPBTouchRequireReclaim ?
          ( (low <= emaFast and close > emaFast) or (not na(bullLevel) and low <= bullLevel and close > bullLevel) )
        :
          ( (low <= emaFast) or (not na(bullLevel) and low <= bullLevel) )
     )

float pbHighMax    = ta.highest(high, bullPBStallLookback)
float pbHighMaxPrev = pbHighMax[1]

// ================================
// PB stall-cluster detection + score (NEW)
// ================================
int pbStallCount = 0
for i = 0 to bullPBStallLookback - 1
    bool pbStallBar = math.abs(close[i] - open[i]) <= (bullPBStallBodyATR * atr)
    pbStallCount += pbStallBar ? 1 : 0

bool pbHighFail =
     (not bullPBStallNeedHighFail) or
     (pbHighMax <= pbHighMaxPrev)

// ================================
// PB Early-Assumption veto (cross-coin, log-proven)
// Kills PB entries when continuation is assumed before expansion maturity + absorption.
// ================================
bool pbVeto_EarlyStall_A =
     (bullPBExpAgeBars <= 2) and (pbStallCount == 3) and (bullPBAgeBars <= 6)

bool pbVeto_EarlyStall_B =
     (bullPBExpAgeBars <= 1) and (pbStallCount == 3) and (bullPBAgeBars >= 7) and (adxSlopeNow <= 3.5)

bool pbVeto_MajorImpulseWeak =
     pbMajorImpulse and (bullPBExpAgeBars <= 2) and (adxSlopeNow <= 0)

bool pbVeto_VeryEarlyNoAbsorb =
     (bullPBExpAgeBars <= 1) and (bullPBAgeBars <= 2) and (pbStallCount <= 1)

bool pbVeto_LongStallNoHH =
     (bullLegNoNewHiStreak >= 5) and (pbStallCount <= 1) and (bullPBAgeBars <= 5)

bool bullPBEarlyAssumeVeto =
     pbVeto_EarlyStall_A or pbVeto_EarlyStall_B or pbVeto_MajorImpulseWeak or pbVeto_VeryEarlyNoAbsorb or pbVeto_LongStallNoHH


// --- PB Failed-Continuation veto (NEW) ---
// Blocks late PB attempts that stall (many small bodies) and fail to progress highs.
bool bullPBLateFailVeto =
     bullPBUseLateFail and
     (bullPBImpulseAgeBars >= bullPBLateFailMinImpAgeBars) and
     pbHighFail and
     (pbStallCount >= bullPBLateFailMinStallCount)

bool bullPBStallCluster = (pbStallCount >= bullPBStallMinCount) and pbHighFail

// Hard veto (PB only)
bool bullPBStallVeto = bullPBStallCluster

// Score point: +1 if stall cluster is NOT present
int bullPBScore = bullPBStallCluster ? 0 : 1

// Final PB execution gate
// Option A: structural HH proof (must exceed reclaimed range high = bullLevel)
bool bullPB_HHProofOk =
     bullArmed and
     (not na(bullLevel)) and
     (not na(bullHH)) and
     (bullHH > bullLevel)


// Final PB execution gate
bool bullPBEnterExec = bullPBEnter and bullPBTouchOk and bullPB_HHProofOk and (bullPBScore >= bullPB_MinScore) and (not bullPBStallVeto) and (not bullPBExhaustVeto) and (not bullPBLateVeto) and (not bullPBLifecycleVeto) and (not bullPBLateStallVeto) and (not bullPBAgeVeto) and (not bullPBFreshVeto) and (not bullPBExpAgeVeto) and (not bullPBImpulseChaseVeto) and (not bullPBLateFailVeto) and (not bullPBRetryAfterChaseVeto) and (not bullPBEarlyAssumeVeto)


// ---- PBDEC veto mask (PB-specific) ----
int pbVetoMask = 0
pbVetoMask += (not bullPBTouchOk) ? PBV_TOUCH : 0
pbVetoMask += (not bullPB_HHProofOk) ? PBV_HHPROOF : 0
pbVetoMask += ((bullPBScore < bullPB_MinScore)) ? PBV_SCORE : 0
pbVetoMask += (bullPBStallVeto ? PBV_STALL : 0)
pbVetoMask += (bullPBExhaustVeto ? PBV_EXHAUST : 0)
pbVetoMask += (bullPBLateVeto ? PBV_LATE : 0)
pbVetoMask += (bullPBLifecycleVeto ? PBV_LIFECYCLE : 0)
pbVetoMask += (bullPBLateStallVeto ? PBV_LATE_STALL : 0)
pbVetoMask += (bullPBAgeVeto ? PBV_AGE : 0)
pbVetoMask += (bullPBFreshVeto ? PBV_FRESH : 0)
pbVetoMask += (bullPBExpAgeVeto ? PBV_EXPAGE : 0)
pbVetoMask += (bullPBImpulseChaseVeto ? PBV_IMPULSE_CHASE : 0)
pbVetoMask += (bullPBRetryAfterChaseVeto ? PBV_RETRY_CHASE : 0)
pbVetoMask += (bullPBLateFailVeto ? PBV_LATE_FAIL : 0)
pbVetoMask += (bullPBEarlyAssumeVeto ? PBV_EARLY_ASSUME : 0)


// ---- L2 window log: PB DECISION (exec OR blocked) ----
if exportL2 and barstate.isconfirmed and bullPBEnter
    if L2_active
        L2_dropCnt += 1
    else
        L2_eventId += 1
        L2_active := true
        L2_evtBar := bar_index
        L2_evtType := "PBDEC_BULL_PB_RECLAIM"
        L2_exitReason := ""
        L2_blockedMask := pbVetoMask
        L2_isEntryEvt := false
        L2_isExitEvt := false
        L2_isCandEvt := true
        L2_fwdLeft := l2WindowBars

        // PBDEC fields captured at decision time
        L2_pbAgeBars     := bullPBAgeBars
        L2_pbImpAgeBars  := bullPBImpulseAgeBars
        L2_pbFreshLateOk := bullPBFreshnessLateOk ? 1 : 0
        L2_pbFreshVeto   := bullPBFreshVeto ? 1 : 0
        L2_pbEnterExec   := bullPBEnterExec ? 1 : 0
        L2_pbVetoMask    := pbVetoMask
        L2_pbExpAgeBars := bullPBExpAgeBars
        L2_pbExpAgeVeto := bullPBExpAgeVeto ? 1 : 0
        L2_pbLateVeto        := bullPBLateVeto ? 1 : 0
        L2_pbLifecycleVeto   := bullPBLifecycleVeto ? 1 : 0
        L2_pbAgeVeto         := bullPBAgeVeto ? 1 : 0
        L2_pbFreshMinAge     := bullPBFreshMinAgeBars
        L2_pbMajorImpulseNow := pbMajorImpulse ? 1 : 0
        L2_pbLastMajorImpBar := bullLastMajorImpulseBar


        int szPB = array.size(l2_bi)
        if szPB > 0
            int curIdxPB = szPB - 1
            int maxBackPB = math.min(l2WindowBars, curIdxPB)

            // Backfill: -N..-1
            for j = 1 to maxBackPB
                int i = maxBackPB - j + 1
                int idx = curIdxPB - i
                l2_emitRow(idx, -i, false, false, "", true, pbVetoMask)

            // Emit decision bar as rel=0 (this is the PB decision time row)
            l2_emitRow(curIdxPB, 0, false, false, "", true, pbVetoMask)
            // Emit the event bar (rel=0) with correct flags/reason/mask
            l2_emitRow(curIdx, 0, L2_isEntryEvt, L2_isExitEvt, L2_exitReason, L2_isCandEvt, L2_blockedMask)


// ==============================
// PBDBG: log PB candidates (EXEC + optional BLOCK) to Pine Logs
// ==============================
if exportToLogs and dbgPBProbe and barstate.isconfirmed and bullPBEnter and (dbgPBProbeIncludeBlocked or bullPBEnterExec)
    string pbStatus = bullPBEnterExec ? "EXEC" : "BLOCK"

    float distBullATR = (atr > 0 and not na(bullLevel)) ? ((close - bullLevel) / atr) : na
    float distEFAtr   = (atr > 0) ? ((close - emaFast) / atr) : na
    float pbDepthATR  = (atr > 0) ? (bullPBDepth / atr) : na

    log.info(
    "PBDBG," +
    syminfo.ticker + "," +
    str.tostring(bar_index) + "," +
    fmtDT(time) + "," +
    str.tostring(time) + "," +
    str.tostring(bullPBAgeBars) + "," +
    str.tostring(bullLegNoNewHiStreak) + "," +
    str.tostring(bullPBImpulseAgeBars) + "," +
    str.tostring(bullPBFreshVeto ? 1 : 0) + "," +
    str.tostring(pbMajorImpulse ? 1 : 0) + "," +
    str.tostring(bullMajorImpulseAgeBars) + "," +
    str.tostring(bullPBFreshVeto ? 1 : 0) + "," +
    str.tostring(bullPBDepth / atr) + "," +
    str.tostring(bullPBExtended ? 1 : 0) + "," +
    str.tostring(bullPBShallow ? 1 : 0) + "," +
    str.tostring(bullPBExhaustVeto ? 1 : 0) + "," +
    str.tostring(bullPBLateStallVeto ? 1 : 0) + "," +
    str.tostring(bullPBLifecycleVeto ? 1 : 0) + "," +
    str.tostring(bullPBAgeVeto ? 1 : 0) + "," +
    str.tostring(bullPBTouchOk ? 1 : 0) + "," +
    str.tostring(bullPBEnter ? 1 : 0) + "," +
    str.tostring(bullPBEnterExec ? 1 : 0) + "," +
    str.tostring(bullStartBar) + "," +
    str.tostring(bullPBMaxAgeBars) + "," +
    str.tostring(mode == Mode.Bull ? 1 : 0) + "," +
    str.tostring(bullArmed ? 1 : 0)
)

// --- PB-Guard v2 (exhaustion micro-PB filter) ---

if bullPBEnterExec
    // ---- L1 PB snapshot latched at PB fill (so L1 row can carry PBDEC context) ----
    L1_pbVetoMaskEnt       := pbVetoMask
    L1_pbMajorImpulseEnt   := pbMajorImpulse ? 1 : 0
    L1_pbImpulseAgeBarsEnt := bullPBImpulseAgeBars
    L1_pbStallCountEnt     := pbStallCount
    L1_pbHighFailEnt       := pbHighFail ? 1 : 0
    L1_pbScoreEnt          := bullPBScore
    L1_pbAdxSlopeEnt      := adxSlopeNow
    L1_pbAgeBarsEnt       := bullPBAgeBars
    L1_pbNoNewHiStreakEnt := bullLegNoNewHiStreak
    L1_pbDepthAtrEnt      := bullPBDepth / atr
    L1_pbExpAgeBarsEnt    := bullPBExpAgeBars
    L1_pbTouchOkEnt       := bullPBTouchOk ? 1 : 0
    L1_pbHHProofOkEnt     := bullPB_HHProofOk ? 1 : 0
    strategy.entry("LONG", strategy.long, comment="BULL_PB")
    label.new(
        bar_index,
        high,
        "stallCnt=" + str.tostring(pbStallCount) + 
        " highFail=" + str.tostring(pbHighFail),
        style=label.style_label_down,
        textcolor=color.white,
        color=color.red,
        size=size.small
    )

    // ---- END BULL on entry consumption (STRUCTURE-ANCHORED) ----
    posTag := "BULL"
    entryModeTag := "BULL"
    rbFromPBBlock := false
    L1_pendDir  := "LONG"
    L1_pendReg  := "BULL"
    L1_pendArch := "BULL_PB_RECLAIM"

    L1_pendEntryEngine  := "BULL_PB"
    L1_pendHtfState     := htfOnNow ? "HTF_ON" : "HTF_OFF"
    L1_pendHtfFlipEvent := htfFlipEventNow
    L1_pendLastFlipType := lastBullFlipType
    L1_pendAcceptUpCnt  := bullAcceptUpCnt
    L1_pendQualMask     := qualMask(bullArmed, true, htfOnNow, true)

    L1_pendMode      := modeToStr(mode)
    L1_pendModeScore := l2_modeScoreNow
    L1_pendAdx       := adx
    L1_pendAdxRising := (adxRising ? 1 : 0)

    L1_pendBodyPct   := bodyPct
    L1_pendCloseLoc  := closeLoc
    L1_pendRngAtr    := (atr > 0 ? (rng / atr) : na)

    // Distances (ATR)
    L1_pendDistEFATR := (atr > 0 ? math.abs(close - emaFast) / atr : na)
    L1_pendDistESATR := (atr > 0 ? math.abs(close - emaSlow) / atr : na)

    // Bull-level distance only meaningful for Bull, but safe for others (na if bullLevel na)
    L1_pendDistBullATR := (atr > 0 and not na(bullLevel)) ? math.abs(close - bullLevel) / atr : na

    // Timing context
    L1_pendBSI := l2_barsSince(l2_lastImpulseBar)
    L1_pendBSA := l2_barsSince(l2_lastAcceptBar)
    L1_pendBSR := l2_barsSince(l2_lastReclaimBar)


    entered := true
    bullTP1Done := false
    bullTP0Done := false
    entryMode := Mode.Bull
    // Freeze bullLevel already set; consume bull setup
    bullArmed := false
    pendingBull := false
    pendingBullBar := na
    bullPBSeen := false
    bullPBBar := na
    bullPBLow := na
    bullLastAddBar := na
    bullHH := na
    bullArmRollHigh := na
    bullHHBar := na


else if bullCompEnter
    strategy.entry("LONG", strategy.long, comment="BULL_COMP")

    posTag := "BULL"
    entryModeTag := "BULL"
    rbFromPBBlock := false
    L1_pendDir  := "LONG"
    L1_pendReg  := "BULL"
    L1_pendArch := "BULL_COMP"

    L1_pendEntryEngine  := "BULL_COMP"
    L1_pendHtfState     := htfOnNow ? "HTF_ON" : "HTF_OFF"
    L1_pendHtfFlipEvent := htfFlipEventNow
    L1_pendLastFlipType := lastBullFlipType
    L1_pendAcceptUpCnt  := bullAcceptUpCnt
    L1_pendQualMask     := qualMask(true, false, htfOnNow, bullCompNotChase)

    L1_pendMode      := modeToStr(mode)
    L1_pendModeScore := l2_modeScoreNow
    L1_pendAdx       := adx
    L1_pendAdxRising := (adxRising ? 1 : 0)

    L1_pendBodyPct   := bodyPct
    L1_pendCloseLoc  := closeLoc
    L1_pendRngAtr    := (atr > 0 ? (rng / atr) : na)

    // Distances (ATR)
    L1_pendDistEFATR := (atr > 0 ? math.abs(close - emaFast) / atr : na)
    L1_pendDistESATR := (atr > 0 ? math.abs(close - emaSlow) / atr : na)

    // Bull-level distance only meaningful for Bull, but safe for others (na if bullLevel na)
    L1_pendDistBullATR := (atr > 0 and not na(bullLevel)) ? math.abs(close - bullLevel) / atr : na

    // Timing context
    L1_pendBSI := l2_barsSince(l2_lastImpulseBar)
    L1_pendBSA := l2_barsSince(l2_lastAcceptBar)
    L1_pendBSR := l2_barsSince(l2_lastReclaimBar)

    entered := true
    bullTP1Done := false
    bullTP0Done := false
    entryMode := Mode.Bull

    // Consume setup (COMP consumes the armed state)
    bullArmed := false
    pendingBull := false
    pendingBullBar := na
    bullPBSeen := false
    bullPBBar := na
    bullPBLow := na
    bullLastAddBar := na
    bullHH := na
    bullArmRollHigh := na
    bullHHBar := na


else if bullImpulseEnter
    strategy.entry("LONG", strategy.long, comment="BULL_START")

    posTag := "BULL"
    entryModeTag := "BULL"
    rbFromPBBlock := false
    L1_pendDir  := "LONG"
    L1_pendReg  := "BULL"
    L1_pendArch := "BULL_START"

    L1_pendEntryEngine  := "BULL_START"
    L1_pendHtfState     := htfOnNow ? "HTF_ON" : "HTF_OFF"
    L1_pendHtfFlipEvent := htfFlipEventNow
    L1_pendLastFlipType := lastBullFlipType
    L1_pendAcceptUpCnt  := bullAcceptUpCnt
    L1_pendQualMask     := qualMask(true, false, htfOnNow, (bullStartNotExtended and bullStartNotExtendedEMA and bullStartNoChase))

    L1_pendMode      := modeToStr(mode)
    L1_pendModeScore := l2_modeScoreNow
    L1_pendAdx       := adx
    L1_pendAdxRising := (adxRising ? 1 : 0)

    L1_pendBodyPct   := bodyPct
    L1_pendCloseLoc  := closeLoc
    L1_pendRngAtr    := (atr > 0 ? (rng / atr) : na)

    // Distances (ATR)
    L1_pendDistEFATR := (atr > 0 ? math.abs(close - emaFast) / atr : na)
    L1_pendDistESATR := (atr > 0 ? math.abs(close - emaSlow) / atr : na)

    // Bull-level distance only meaningful for Bull, but safe for others (na if bullLevel na)
    L1_pendDistBullATR := (atr > 0 and not na(bullLevel)) ? math.abs(close - bullLevel) / atr : na

    // Timing context
    L1_pendBSI := l2_barsSince(l2_lastImpulseBar)
    L1_pendBSA := l2_barsSince(l2_lastAcceptBar)
    L1_pendBSR := l2_barsSince(l2_lastReclaimBar)

    entered := true
    bullTP1Done := false
    bullTP0Done := false
    entryMode := Mode.Bull

    // Consume setup
    bullImpulseDone := true
    bullArmed := false
    pendingBull := false
    pendingBullBar := na
    bullPBSeen := false
    bullPBBar := na
    bullPBLow := na
    bullLastAddBar := na
    bullHH := na
    bullArmRollHigh := na
    bullHHBar := na



    // keep bullStructLow for invalidation

if barstate.isconfirmed and bullAddEnter
    strategy.entry("LONG_ADD", strategy.long)
    bullLastAddBar := bar_index
    c_addSig += 1
    if exportToLogs
        L1_addCount += 1


    // ---- L2 window log: ADD (separate from trade open/close) ----
    if exportL2
        if not L2_active
            L2_eventId += 1
            L2_active := true
            L2_evtBar := bar_index
            L2_evtType := "ENTRY_BULL_ADD"
            L2_exitReason := ""
            L2_blockedMask := 0
            L2_isEntryEvt := true
            L2_isExitEvt := false
            L2_isCandEvt := false
            L2_fwdLeft := l2WindowBars

            int szA = array.size(l2_bi)
            if szA > 0
                int curIdxA = szA - 1
                int maxBackA = math.min(l2WindowBars, curIdxA)
                for j = 1 to maxBackA
                    int i = maxBackA - j + 1
                    int idx = curIdxA - i
                    l2_emitRow(idx, -i, false, false, "", false, 0)

                // Emit the event bar (rel=0) with correct flags/reason/mask
                l2_emitRow(curIdx, 0, L2_isEntryEvt, L2_isExitEvt, L2_exitReason, L2_isCandEvt, L2_blockedMask)

if rangeAEnter
    strategy.entry("LONG", strategy.long, comment="RANGE_A")
    posTag := "RANGEA"
    entryModeTag := "RANGE-A"
    rbFromPBBlock := false
    L1_pendDir  := "LONG"
    L1_pendReg  := "RANGE-A"
    L1_pendArch := "RA_DISCOUNT_RECLAIM"

    L1_pendEntryEngine  := "RA_ENTRY"
    L1_pendHtfState     := htfOnNow ? "HTF_ON" : "HTF_OFF"
    L1_pendHtfFlipEvent := htfFlipEventNow
    L1_pendLastFlipType := lastBullFlipType
    L1_pendAcceptUpCnt  := bullAcceptUpCnt
    L1_pendQualMask     := qualMask(raReclaimExecOk, raWasBelow, (not htfOnNow), (raRiskOk and raRROkHard))

    L1_pendMode      := modeToStr(mode)
    L1_pendModeScore := l2_modeScoreNow
    L1_pendAdx       := adx
    L1_pendAdxRising := (adxRising ? 1 : 0)

    L1_pendBodyPct   := bodyPct
    L1_pendCloseLoc  := closeLoc
    L1_pendRngAtr    := (atr > 0 ? (rng / atr) : na)

    // Distances (ATR)
    L1_pendDistEFATR := (atr > 0 ? math.abs(close - emaFast) / atr : na)
    L1_pendDistESATR := (atr > 0 ? math.abs(close - emaSlow) / atr : na)

    // Bull-level distance only meaningful for Bull, but safe for others (na if bullLevel na)
    L1_pendDistBullATR := (atr > 0 and not na(bullLevel)) ? math.abs(close - bullLevel) / atr : na

    // Timing context
    L1_pendBSI := l2_barsSince(l2_lastImpulseBar)
    L1_pendBSA := l2_barsSince(l2_lastAcceptBar)
    L1_pendBSR := l2_barsSince(l2_lastReclaimBar)

    entered := true
    entryMode := Mode.RangeA
    // Freeze RA targets on entry
    raTPMid   := raDL_mid
    raStopBase := raUseFallback ? raDL_low : ((not na(raStructLow) and (na(raStructGap_ATR) or raStructGap_ATR <= raStructStopMaxGap_ATR)) ? raStructLow : raDL_low)
    raEntryBar:= bar_index

// Track entry bar for global exit gating
if entered
    lastEntryBar := bar_index
    tradeHi := high
    tradeLo := low

// ---- L2 window log: ENTRY ----
if entered and exportL2 and barstate.isconfirmed
    string _evtType = "ENTRY_" + entryModeTag
    int _mask = 0
    bool _isEntry = true
    bool _isExit  = false
    bool _isCand  = false

    if L2_active
        L2_dropCnt += 1
    else
        L2_eventId += 1
        L2_active := true
        L2_evtBar := bar_index
        L2_evtType := _evtType
        L2_exitReason := ""
        L2_blockedMask := _mask
        L2_isEntryEvt := _isEntry
        L2_isExitEvt := _isExit
        L2_isCandEvt := _isCand
        L2_fwdLeft := l2WindowBars

        int sz = array.size(l2_bi)
        if sz > 0
            int curIdx = sz - 1
            int maxBack = math.min(l2WindowBars, curIdx)

           // Backfill: -N..-1
            for j = 1 to maxBack
                int i = maxBack - j + 1
                int idx = curIdx - i
                l2_emitRow(idx, -i, false, false, "", false, 0)

            // Emit the event bar (rel=0) with correct flags/reason/mask
            l2_emitRow(curIdx, 0, L2_isEntryEvt, L2_isExitEvt, L2_exitReason, L2_isCandEvt, L2_blockedMask)


    // Initialize ADD reference on fresh Bull entries
    if entryModeTag == "BULL"
        bullAddRefHi := high

//====================================================
// In-trade tracking (MFE/MAE)
//====================================================

// --- Bull-leg stall tracking (runs even when flat) ---
// Counts consecutive confirmed bars with NO new bull-leg high while Bull is armed.
l2_pushBar_impl()

if barstate.isconfirmed
    if bullArmed and (not bearActive) and (not pendingBear)
        float prevHi = nz(bullLegHi[1], na)
        bullLegHi := na(bullLegHi) ? high : math.max(bullLegHi, high)
        bool madeNewHi = (not na(prevHi)) and (bullLegHi > prevHi)
        if madeNewHi
            bullLastExpansionBar := bar_index
        bullLegNoNewHiStreak := madeNewHi ? 0 : (nz(bullLegNoNewHiStreak[1]) + 1)
    else
        bullLegHi := na
        bullLegNoNewHiStreak := 0

if inPos
    tradeHi := na(tradeHi) ? high : math.max(tradeHi, high)
    tradeLo := na(tradeLo) ? low  : math.min(tradeLo, low)

// ---- Bull runner stall tracking (confirmed only) ----
// Counts consecutive confirmed bars with NO new tradeHi while in BULL.
if barstate.isconfirmed
    if inPos and posTag == "BULL"
        bullNoNewHiStreak := (tradeHi <= nz(tradeHi[1])) ? (nz(bullNoNewHiStreak[1]) + 1) : 0
    else
        bullNoNewHiStreak := 0

// --- Close-based stall tracking (fix for wick-chop) ---
var float bullBestClose = na
var int   bullNoNewCloseStreak = 0

if (not inPos) or (not isLong) or (posTag != "BULL")
    bullBestClose := na
    bullNoNewCloseStreak := 0
else
    bullBestClose := na(bullBestClose) ? close : math.max(bullBestClose, close)
    bullNoNewCloseStreak := (close >= bullBestClose[1]) ? 0 : (bullNoNewCloseStreak + 1)


//====================================================
// L2 Candidate events (missed-opportunity triggers) + blocked masks
//====================================================

// --- Candidate: Bull PB reclaim signal existed, but entry didn't happen (flat)
bullCand = barstate.isconfirmed and (not inPos) and bullReclaimNow

bullCandBlocked =
     bullCand and (
        (mode != Mode.Bull) or
        (not scoreGateOk(Mode.Bull)) or
        (not bullLocalTrendOk) or
        (not htfBullOk) or
        (bullUseDMI and not (pdi > mdi)) or
        (not adxBullPBExecOk) or
        bearActive or pendingBear
     )

bullBlkMask = 0
bullBlkMask += (not htfBullOk) ? BLK_HTF : 0
bullBlkMask += (not adxBullPBExecOk) ? BLK_ADX : 0
bullBlkMask += ((mode != Mode.Bull)) ? BLK_WINDOW : 0
bullBlkMask += (not scoreGateOk(Mode.Bull)) ? BLK_SCORE : 0
bullBlkMask += ((bearActive or pendingBear)) ? BLK_BEAR : 0
bullBlkMask += ((not bullLocalTrendOk) ? BLK_OTHER : 0)

// --- Candidate: RA decision event exists, but entry didn't happen
raCand = barstate.isconfirmed and (not inPos) and raDecision

raCandBlocked =
     raCand and (
        (mode != Mode.RangeA) or
        (not raEntryOk)   // includes risk/RR, RSI, ADX, etc.
     )

raBlkMask = 0
raBlkMask += (mode != Mode.RangeA) ? BLK_WINDOW : 0
raBlkMask += ((not adxRAOk) ? BLK_ADX : 0)
raBlkMask += ((not raRiskOk or not raRROkHard) ? BLK_OTHER : 0)
raBlkMask += ((not raRsiOk) ? BLK_OTHER : 0)
raBlkMask += ((bearActive or pendingBear or (not bearLockoutOk)) ? BLK_BEAR : 0)
raBlkMask += ((not htfOffForRA) ? BLK_HTF : 0)

// --- Candidate: Bear breakdown exists, but entry didn't happen
bearCand = barstate.isconfirmed and (not inPos) and bearShortBreakdownNow

bearCandBlocked =
     bearCand and (
        (not bearShortEnter)
     )

bearBlkMask = 0
bearBlkMask += ((not bearShortADXOk) ? BLK_ADX : 0)
bearBlkMask += ((not bearReentryOk) ? BLK_SPACING : 0)
bearBlkMask += ((not shortCooldownOk) ? BLK_HTF : 0)
bearBlkMask += ((not bearLocalDowntrendOk) ? BLK_OTHER : 0)




// ---- L2 window log: CANDIDATES (missed opportunities) ----
if exportL2 and barstate.isconfirmed and (not inPos)
    string _evtType = ""
    int _mask = 0
    bool _fire = false

    if bullCandBlocked
        _evtType := "CAND_BULL_PB_RECLAIM"
        _mask := bullBlkMask
        _fire := true
    else if raCandBlocked
        _evtType := "CAND_RA_DECISION"
        _mask := raBlkMask
        _fire := true
    else if bearCandBlocked
        _evtType := "CAND_BEAR_BREAKDOWN"
        _mask := bearBlkMask
        _fire := true

    if _fire
        bool _isEntry = false
        bool _isExit  = false
        bool _isCand  = true

        if L2_active
            L2_dropCnt += 1
        else
            L2_eventId += 1
            L2_active := true
            L2_evtBar := bar_index
            L2_evtType := _evtType
            L2_exitReason := ""
            L2_blockedMask := _mask
            L2_isEntryEvt := _isEntry
            L2_isExitEvt := _isExit
            L2_isCandEvt := _isCand
            L2_fwdLeft := l2WindowBars

            int sz = array.size(l2_bi)
            if sz > 0
                int curIdx = sz - 1
                int maxBack = math.min(l2WindowBars, curIdx)

                // Backfill: -N..-1
                for j = 1 to maxBack
                    int i = maxBack - j + 1
                    int idx = curIdx - i
                    l2_emitRow(idx, -i, false, false, "", false, 0)
                // Emit the event bar (rel=0) with correct flags/reason/mask
                l2_emitRow(curIdx, 0, L2_isEntryEvt, L2_isExitEvt, L2_exitReason, L2_isCandEvt, L2_blockedMask)


//====================================================
// L1 max-fav/max-adv tracking (bar index + price)
//====================================================
if exportToLogs and inPos
    if strategy.position_size > 0
        // LONG: favorable = higher high, adverse = lower low
        if na(L1_maxFavPx) or (high > L1_maxFavPx)
            L1_maxFavPx  := high
            L1_maxFavBar := bar_index
        if na(L1_maxAdvPx) or (low < L1_maxAdvPx)
            L1_maxAdvPx  := low
            L1_maxAdvBar := bar_index
    else
        // SHORT: favorable = lower low, adverse = higher high
        if na(L1_maxFavPx) or (low < L1_maxFavPx)
            L1_maxFavPx  := low
            L1_maxFavBar := bar_index
        if na(L1_maxAdvPx) or (high > L1_maxAdvPx)
            L1_maxAdvPx  := high
            L1_maxAdvBar := bar_index


//====================================================
// Exits + Time-stops + Downgrades + Success criteria
//====================================================
exitOk = na(lastEntryBar) or (bar_index > lastEntryBar)

//====================================================
// Close helpers (NO close_all; close by entry_id)
//====================================================
closeLongAll(_comment) =>
    // Close both possible long entry-ids used by this script.
    strategy.close("LONG",     comment=_comment)
    strategy.close("LONG_ADD", comment=_comment)

closeShortAll(_comment) =>
    // Close both possible short entry-ids used by this script.
    strategy.close("SHORT",    comment=_comment)
    strategy.close("RB_SHORT", comment=_comment)


// Targets
float bullTP0Price = (inPos and posTag == "BULL")
     ? (strategy.position_avg_price + atr * bullTP0_ATR)
     : na

bool bullTP0Hit =
     inPos and
     (posTag == "BULL") and
     (not bullTP0Done) and
     (not na(bullTP0Price)) and
     (high >= bullTP0Price)

float bullTP1Price = (inPos and posTag == "BULL")
     ? (strategy.position_avg_price + atr * bullTP1_ATR)
     : na

bool bullTP1Hit =
     inPos and
     (posTag == "BULL") and
     (not bullTP1Done) and
     (not na(bullTP1Price)) and
     (high >= bullTP1Price)
float bearTP0Price = (inPos and posTag == "BEAR")
     ? (strategy.position_avg_price - atr * bearTP0_ATR)
     : na

bool bearTP0Hit =
     inPos and
     (posTag == "BEAR") and
     (not bearTP0Done) and
     (not na(bearTP0Price)) and
     (close <= bearTP0Price)

// Bear TP1 target: 0.8R based on stop distance (bearReclLvl - entry). Fallback to ATR target if stop distance is unknown.
float bearRisk = (inPos and posTag == "BEAR" and not na(bearReclLvl)) ? (bearReclLvl - strategy.position_avg_price) : na

float bearTP1Price = (inPos and posTag == "BEAR")
     ? (
         (not na(bearRisk) and bearRisk > 0)
             ? (strategy.position_avg_price - bearRisk * bearTP1_R)
             : (strategy.position_avg_price - atr * bearTP1_ATR)
       )
     : na

bool bearTP1Hit =
     inPos and
     (posTag == "BEAR") and
     (not bearTP1Done) and
     (not na(bearTP1Price)) and
     (close <= bearTP1Price)

var int bullTP1Bar = na
if bullTP1Hit
    bullTP1Bar := bar_index
if not inPos
    bullTP1Bar := na
if not inPos 
    bearTP1Done := false 
if not inPos 
    bearTP0Done := false 
if not inPos 
    bearTP0Bar := na 
if not inPos 
    bearTP0Lo := na 
if not inPos 
    bearTP0EntryPx := na
if not inPos
    bullTP0Done := false

//====================================================
// Bull TP0 partial (early de-risk; mirrors BEAR_TP0)
//====================================================
if exitOk and bullTP0Hit
    strategy.close("LONG", qty_percent=bullTP0_Pct, comment="BULL_TP0")
    bullTP0Done := true

    // NOTE: TP0 is a partial, but not TP1 -> do NOT touch L1_tp1Hit or c_tp1Hits here.

    if exportToLogs
        L1_nPartials += 1
        L1_partialPctSum += bullTP0_Pct
        if na(L1_firstPartialBar)
            L1_firstPartialBar := bar_index
            L1_firstPartialTime := time
        L1_lastPartialBar := bar_index
        L1_lastPartialTime := time
        L1_partialReasons := (L1_partialReasons == "" ? "BULL_TP0" : (L1_partialReasons + "|" + "BULL_TP0"))

//====================================================
// Bull TP1 partial (kept separate from full exits)
//====================================================
if exitOk and bullTP1Hit
    // partial close ONLY the base long id
    strategy.close("LONG", qty_percent=bullTP1_Pct, comment="BULL_TP1")
    bullTP1Done := true
    if exportToLogs
        L1_tp1Hit := true
    c_tp1Hits += 1

    // ---- L1 partial aggregates (for the full trade) ----
    if exportToLogs
        L1_nPartials += 1
        L1_partialPctSum += bullTP1_Pct
        if na(L1_firstPartialBar)
            L1_firstPartialBar := bar_index
            L1_firstPartialTime := time
        L1_lastPartialBar := bar_index
        L1_lastPartialTime := time
        L1_partialReasons := (L1_partialReasons == "" ? "BULL_TP1" : (L1_partialReasons + "|" + "BULL_TP1"))

if exitOk and bearTP0Hit 
    strategy.close("SHORT", qty_percent=bearTP0_Pct, comment="BEAR_TP0") 
    bearTP0Done := true 
    bearTP0Bar := bar_index 
    bearTP0Lo := tradeLo 
    bearTP0EntryPx := strategy.position_avg_price

    // NOTE: TP0 is a partial, but not TP1 -> do NOT touch L1_tp1Hit or c_tp1Hits here.

    if exportToLogs
        L1_nPartials += 1
        L1_partialPctSum += bearTP0_Pct
        if na(L1_firstPartialBar)
            L1_firstPartialBar := bar_index
            L1_firstPartialTime := time
        L1_lastPartialBar := bar_index
        L1_lastPartialTime := time
        L1_partialReasons := (L1_partialReasons == "" ? "BEAR_TP0" : (L1_partialReasons + "|" + "BEAR_TP0"))

if exitOk and bearTP1Hit
    // partial close ONLY the base short id
    strategy.close("SHORT", qty_percent=bearTP1_Pct, comment="BEAR_TP1")
    bearTP1Done := true
    if exportToLogs
        L1_tp1Hit := true
    c_tp1Hits += 1

    // ---- L1 partial aggregates (for the full trade) ----
    if exportToLogs
        L1_nPartials += 1
        L1_partialPctSum += bearTP1_Pct
        if na(L1_firstPartialBar)
            L1_firstPartialBar := bar_index
            L1_firstPartialTime := time
        L1_lastPartialBar := bar_index
        L1_lastPartialTime := time
        L1_partialReasons := (L1_partialReasons == "" ? "BEAR_TP1" : (L1_partialReasons + "|" + "BEAR_TP1"))

// RA TP / success
raTPLevel = not na(raTPMid) ? raTPMid : rollMid
raTPHit = inPos and (posTag == "RANGEA") and (close >= raTPLevel)
raStopLevel = not na(raStopBase) ? (raStopBase - atr * raStop_ATR) : na
raStopHit = inPos and (posTag == "RANGEA") and not na(raStopLevel) and (close < raStopLevel) and (not raStopNeed2Cl or close[1] < raStopLevel)

// Time-stops
bullMFE = (inPos and posTag=="BULL") ? (tradeHi - strategy.position_avg_price) : 0.0
bullBarsIn = (inPos and posTag=="BULL" and not na(lastEntryBar)) ? (bar_index - lastEntryBar) : 0

// PB time-stop (engine-isolated): applies ONLY if the entryEngine that opened this position was BULL_PB
pbTimeStop = inPos and posTag=="BULL" and (L1_entryEngine == "BULL_PB") and (bullBarsIn >= pbTS_Bars)

bullTimeStop = inPos and posTag=="BULL" and (bullBarsIn >= bullTS_Bars) and (bullMFE < atr * bullTS_MinMFE_ATR)

//====================================================
// Bull MOM_LOSS (runner-only exit AFTER TP1) — Option B (gated)
// Intent: after TP1, if continuation fails (stall + rollover), exit before BULL_INV,
// BUT only in "weak context" (post-HTF weakening / post-cycle conditions).
//====================================================
int bullMomNoHHBars = 8          // stall window (no new highs)
//int bullMomEmaCloses = 2         // rollover confirmation (consecutive closes below EMAfast)

bool bullAfterEnd = inPos and isLong and (posTag == "BULL") and (not na(bullEndBar)) and (bar_index >= bullEndBar)
int  tp1AgeBars   = bullTP1Done ? (bar_index - bullTP1Bar) : 999999
bool tp1RecentOk  = bullTP1Done and (tp1AgeBars <= bullMomMaxBarsAfterTP1)

int bullMomEmaCloses = (bullTP1Done and tp1RecentOk) ? bullMomEmaClosesAfterEnd : 2
bool bullEmaRoll = (bullMomEmaCloses == 2) ? (close < emaFast and close[1] < emaFast) : (close < emaFast)


// Runner-only: only after TP1 is done
// Giveback-from-peak guard: prevents premature exits during healthy digestion.
float bullGiveback = inPos and isLong and (posTag=="BULL") ? (tradeHi - close) : 0.0
float gbATR = (bullTP1Done and tp1RecentOk) ? bullMomGivebackATR_AfterEnd : 0.60
bool bullGivebackOk = bullGiveback >= (atr * gbATR)

int momBars = (bullTP1Done and tp1RecentOk) ? bullMomBarsAfterEndBull : bullMomNoHHBars
bool stallOk = (bullNoNewCloseStreak >= momBars)

// Raw MOM_LOSS: TP1 must be done + stall + rollover + meaningful giveback
bool bullMomLossRaw =
     inPos and isLong and (posTag == "BULL") and bullTP1Done and tp1RecentOk and
     stallOk and bullEmaRoll and bullGivebackOk


// Option B: weak-context gate (HTF OFF / HTF neutral / HTF_OFF flip bar)
bool momLossWeakCtx =
     (bullMomLossAllowHTFOff     and (not htfTrendOk)) or
     (bullMomLossAllowHTFNeutral and htfNeutral) or
     (bullMomLossAllowHTFFlipOff and (htfFlipEventNow == "HTF_OFF")) or
     (bullMomLossAllowAfterEndBull and (posTag == "BULL") and inPos and (not na(bullEndBar)) and (bar_index >= bullEndBar)) or
     (bullMomLossAllowAfterTP1Roll and inPos and isLong and (posTag == "BULL") and bullTP1Done and tp1RecentOk and (close < emaFast))

// Final gated signal
bool bullMomLoss =
     bullMomLossOn and bullMomLossRaw and (not bullMomLossGateWeak or momLossWeakCtx)

raBarsIn = (inPos and posTag=="RANGEA" and not na(raEntryBar)) ? (bar_index - raEntryBar) : 0
raTimeStop = inPos and posTag=="RANGEA" and (raBarsIn >= raTS_Bars)

// Bear SHORT time-stop (must pay quickly)
bearMFE = (inPos and posTag=="BEAR") ? (strategy.position_avg_price - tradeLo) : 0.0

// ---- BEAR post-TP0 proof window (remainder-only) ----
int bearTP0ProofWinBars = 2
float bearTP0ProofExtPct = 0.30
float bearTP0AddExtPct = (inPos and posTag=="BEAR" and bearTP0Done and not na(bearTP0Bar) and not na(bearTP0Lo) and not na(bearTP0EntryPx) and bearTP0EntryPx > 0) ? ((bearTP0Lo - tradeLo) / bearTP0EntryPx) * 100.0 : 0.0
bool bearTP0ProofDue = inPos and posTag=="BEAR" and bearTP0Done and (not bearTP1Done) and (not na(bearTP0Bar)) and (bar_index >= (bearTP0Bar + bearTP0ProofWinBars))
bool bearTP0NoExtExit = bearTP0ProofDue and (bearTP0AddExtPct < bearTP0ProofExtPct)

bearBarsIn = (inPos and posTag=="BEAR" and not na(lastEntryBar)) ? (bar_index - lastEntryBar) : 0
bearTimeStop = inPos and posTag=="BEAR" and (bearBarsIn >= bearTS_Bars) and (bearMFE < atr * bearTS_MinMFE_ATR)

// RB SHORT time-stop (must pay quickly)
rbSMFE = (inPos and posTag=="RANGEB" and isShort) ? (strategy.position_avg_price - tradeLo) : 0.0
rbSBarsIn = (inPos and posTag=="RANGEB" and isShort and not na(lastEntryBar)) ? (bar_index - lastEntryBar) : 0
rbShortTimeStop = inPos and (posTag=="RANGEB") and isShort and (rbSBarsIn >= rbS_TS_Bars) and (rbSMFE < atr * rbS_TS_MinMFE_ATR)


// Range-B time-stop (transitional regime): if RB attempt/pending/active too long while flat, force downgrade
rbTSStartBar = not na(rbStartBar) ? rbStartBar : rbAttemptBar
rbBarsActive = (not na(rbTSStartBar)) ? (bar_index - rbTSStartBar) : 0
rbFlatTimeStop = (not inPos) and (rbAttempt or rbPending or rbActive) and not na(rbTSStartBar) and (rbBarsActive >= rbTS_Bars)

//====================================================
// EXIT EXECUTION + L1/L2 latching (NO close_all)
//====================================================

// --- Build a single "exit event" per bar (priority order) ---
bool doExit = false
string exitReason = ""
string exitReg = ""   // "BULL"/"RANGE-A"/"RANGE-B"/"BEAR"

// Priority: Bear kill-switch > hard invalidations > stops > TP > time-stops
if exitOk and inPos
    // 1) Bear kill-switch (longs only)
    if (not doExit) and bearExitNow and isLong
        doExit := true
        exitReason := "BEAR_KILL"
        exitReg := "BEAR"
    // 2) Bull momentum-loss (runner-only, after TP1)
    if (not doExit) and bullMomLoss
        doExit := true
        exitReason := "BULL_MOM_LOSS"
        exitReg := "BULL"

    // 3) Bull invalidation (fallback)
    if (not doExit) and bullCloseInvalid
        doExit := true
        exitReason := "BULL_INV"
        exitReg := "BULL"

    // 3) Short invalidations
    // 3a) BEAR trail exit (post-TP1 trail reclaim)
    if (not doExit) and bearInvPostTrail 
        doExit := true 
        exitReason := "BEAR_TRAIL" 
        exitReg := "BEAR"
    // 3a.5) BEAR post-TP0 no-extension exit (remainder proof failed)
    if (not doExit) and bearTP0NoExtExit 
        doExit := true 
        exitReason := "BEAR_TP0_NOEXT" 
        exitReg := "BEAR"
    // 3b) Other BEAR invalidations
    if (not doExit) and bearShortInvalid 
        doExit := true 
        exitReason := "BEAR_INV" 
        exitReg := "BEAR"

    if (not doExit) and rbShortInvalid
        doExit := true
        exitReason := "RB_INV"
        exitReg := "RANGE-B"

    // 4) RA stop
    if (not doExit) and raStopHit
        doExit := true
        exitReason := "RA_STOP"
        exitReg := "RANGE-A"

    // 5) RA TP
    if (not doExit) and raTPHit
        doExit := true
        exitReason := "RA_TP"
        exitReg := "RANGE-A"

    // 6) Bear force close on expiry (your deferred flag)
    if (not doExit) and bearForceCloseShort
        doExit := true
        exitReason := "BEAR_EXPIRE_FORCE"
        exitReg := "BEAR"

    // 7) Time-stops (must pay quickly)
    if (not doExit) and pbTimeStop
        doExit := true
        exitReason := "BULL_PB_TS"
        exitReg := "BULL"

    if (not doExit) and bullTimeStop
        doExit := true
        exitReason := "BULL_TS"
        exitReg := "BULL"

    if (not doExit) and raTimeStop
        doExit := true
        exitReason := "RA_TS"
        exitReg := "RANGE-A"

    if (not doExit) and bearTimeStop
        doExit := true
        exitReason := "BEAR_TS"
        exitReg := "BEAR"

    if (not doExit) and rbShortTimeStop
        doExit := true
        exitReason := "RB_TS"
        exitReg := "RANGE-B"


// --- L1 latch BEFORE sending close orders (so posClosed row gets exitReason) ---
if exportToLogs and doExit
    L1_exitPending := true
    L1_exitReason  := exitReason
    L1_regExit     := exitReg


// --- Execute full closes (no close_all) ---
if doExit
    if isLong
        closeLongAll(exitReason)
    else
        closeShortAll(exitReason)

    // defer state resets until flat
    pendingReset := true


//====================================================
// L2 EXIT window log (same mechanics as ENTRY/CAND)
//====================================================
if exportL2 and barstate.isconfirmed and doExit
    string _evtType = "EXIT_" + logModeNow()
    int _mask = 0
    bool _isEntry = false
    bool _isExit  = true
    bool _isCand  = false

    if L2_active
        L2_dropCnt += 1
    else
        L2_eventId += 1
        L2_active := true
        L2_evtBar := bar_index
        L2_evtType := _evtType
        L2_exitReason := exitReason
        L2_blockedMask := _mask
        L2_isEntryEvt := _isEntry
        L2_isExitEvt := _isExit
        L2_isCandEvt := _isCand
        L2_fwdLeft := l2WindowBars

        int sz = array.size(l2_bi)
        if sz > 0
            int curIdx = sz - 1
            int maxBack = math.min(l2WindowBars, curIdx)

            // Backfill: -N..-1
            for j = 1 to maxBack
                int i = maxBack - j + 1
                int idx = curIdx - i
                l2_emitRow(idx, -i, false, false, "", false, 0)
            // Emit the event bar (rel=0) with correct flags/reason/mask
            l2_emitRow(curIdx, 0, L2_isEntryEvt, L2_isExitEvt, L2_exitReason, L2_isCandEvt, L2_blockedMask)

// Apply deferred resets once we are actually flat
if pendingReset and (not inPos)
    pendingReset := false

    // --- RESET AFTER FLAT (centralized) ---
    posTag := ""
    entryModeTag := ""
    lastEntryBar := na
    tradeHi := na
    tradeLo := na

    raTPMid     := na
    raStopBase  := na
    raEntryBar  := na
    raStructLow := na
    raDL_low    := na
    raDL_high   := na
    raDL_mid    := na
    raDL_bar    := na
    bullTP1Done := false
    bullTP0Done := false
    bullStructLow := na
    bullLevel     := na
    bullLastAddBar := na
    bullImpulseDone := false
    bullAddRefHi := na
    
    bearPBSeen := false
    bearPBBar  := na
    bearForceCloseShort := false

    rbSPBSeen := false
    rbSPBBar  := na
    rbSValue  := na
    // L1 monetization flags reset per full trade
    L1_tp1Hit := false
    L1_trailEver := false

//====================================================
// ADX split verification — event counters (NO candle spam)
//====================================================
var int c_setupNoADX = 0
var int c_setupWithADX = 0
var int c_reclaim = 0
var int c_blockedExecADX = 0
var int c_blockedRegimeADX = 0
var int c_reclaim_withADX = 0
var int c_reclaim_noADX   = 0



//====================================================
// Range-A diagnostics — event counters (NO candle spam)
//====================================================
var int c_raContext = 0
var int c_raDiscNow = 0
var int c_raDiscRecent = 0
var int c_raSnapReady = 0
var int c_raReclaimOk = 0
var int c_raEntryOk = 0
var int c_raWasBelow = 0
var int c_raAccept2Cl = 0
var int c_raAccept1Cl = 0
var int c_raWasBelow_inRA  = 0
var int c_raAccept2Cl_inRA = 0



// Block reasons (mutually non-exclusive counters)
var int c_raBlock_htfOn = 0
var int c_raBlock_bearAcc  = 0
var int c_raBlock_bearPend = 0
var int c_raBlock_bearLockout = 0
var int c_raBlock_notBalance = 0
var int c_raBlock_notDiscRecent = 0
var int c_raBlock_notReclaim = 0
var int c_raBlock_rsi = 0
var int c_raBlock_struct = 0
var int c_raBlock_adx = 0
var int c_raBlock_rsiOnly = 0
var int c_raBlock_adxOnly = 0
var int c_raBlock_rsiAndAdx = 0
var int c_raBlock_risk = 0
var int c_raBlock_rr   = 0
var int c_raBlock_farFromLow = 0
var int c_raBlock_belowMid = 0



bullTruthLive_flat = (not inPos) and (pendingBull or bullArmed or bullPBSeen)

// “Would be Bull mode if ADX regime didn’t exist”
setupNoADX   = bullTruthLive_flat and htfTrendOk
setupWithADX = bullTruthLive_flat and htfTrendOk and adxBullRegimeOk

// “We got a valid reclaim signal”
reclaimSig = (not inPos) and bullReclaimNow
reclaimWithADX = reclaimSig and adxBullRegimeOk
reclaimNoADX   = reclaimSig and (not adxBullRegimeOk)


// “Would enter, but Exec ADX blocks it”
enterWould = (not inPos) and (mode == Mode.Bull) and bullReclaimNow and htfTrendOk
blockedByExecADX = enterWould and (not adxBullExecOk)
// “We had a reclaim signal + HTF ON, but Bull mode was NOT selected because regime ADX gate failed”
blockedByRegimeADX = (not inPos) and reclaimSig and htfTrendOk and (not adxBullRegimeOk)
raWorld = (not inPos) and (mode == Mode.RangeA)


// Count only on confirmed bars
if barstate.isconfirmed
    if setupNoADX
        c_setupNoADX += 1
    if setupWithADX
        c_setupWithADX += 1
    if reclaimSig
        c_reclaim += 1
    if blockedByExecADX
        c_blockedExecADX += 1
    if reclaimWithADX
        c_reclaim_withADX += 1
    if reclaimNoADX
        c_reclaim_noADX += 1
    if blockedByRegimeADX
        c_blockedRegimeADX += 1
    // Global (flat)
    if (not inPos) and raWasBelow
        c_raWasBelow += 1
    if (not inPos) and raAccept2Cl
        c_raAccept2Cl += 1
    if (not inPos) and raAccept1Cl
        c_raAccept1Cl += 1

    if bullTrailArmed
        c_bullTrailArmed += 1

    // In RangeA world (router-selected)
    if raWorld and raWasBelow
        c_raWasBelow_inRA += 1
    if raWorld and raAccept2Cl
        c_raAccept2Cl_inRA += 1

//====================================================
// ADD fill detection (confirmed only, counts ONLY true adds)
//====================================================
if barstate.isconfirmed
    float posNow  = strategy.position_size
    float posPrev = nz(prevPosSize, 0)

    bool isAddFill = (posPrev > 0) and (posNow > posPrev)

    if isAddFill
        c_addFill += 1
        if posTag == "BULL"
            // lock new add reference at the current high-water mark
            bullAddRefHi := tradeHi

    prevPosSize := posNow


//====================================================
// Range-A diagnostics counting (CONFIRMED bars only) — SCOPED TO ENTRY-DECISION
//====================================================

// 2) The decision point: reclaim is ready and we'd consider executing,
//    but we haven't applied the last vetoes yet.
raDecisionNotBalance = raDecision and (not raInBalance)

// --- RA milestone flags for HUD counters ---
raMil_discRecent = (not inPos) and raDiscRecent
raMil_snapReady  = (not inPos) and raSnapReady

// --- RA block reasons in "RA world" (why RA isn't progressing) ---
raBlock_notBalance     = raWorld and (not (raInBalance or raBalSnapOk))
raBlock_notDiscRecent  = raWorld and (not raDiscRecent)
raBlock_notReclaim     = raWorld and raDiscRecent and (not raReclaimExecOk)


// 3) Decompose ONLY the vetoes that can still kill the trade at raDecision
raVeto_htfOn        = raDecision and (not htfOffForRA)
raVeto_bearAccepted = raDecision and raWorld and bearActive
raVeto_bearPending  = raDecision and raWorld and pendingBear
raVeto_bearLockout  = raDecision and (not bearLockoutOk)
raVeto_rsi         = raDecision and (not raRsiOk)
raVeto_struct      = raDecision and (not raStructSnapOk)
raVeto_adx         = raDecision and (not adxRAOk)
raVeto_farFromLow = raDecision and raUseNearLow and (not raNearLowOk)
raVeto_belowMid = raDecision and raRequireBelowMid and (not raBelowMidOk)
raVeto_risk = raDecision and raEntryOkRaw and (not raRiskOk)
raVeto_rr = raDecision and raEntryOkRaw and raRiskOk and (not raRROkHard)
raVeto_rsiOnly   = raDecision and (not raRsiOk) and adxRAOk
raVeto_adxOnly   = raDecision and raRsiOk and (not adxRAOk)
raVeto_rsiAndAdx = raDecision and (not raRsiOk) and (not adxRAOk)


// 4) "Would enter if mode allowed" check
raWouldEnter = raDecision and htfOffForRA and bearLockoutOk and
     (raInBalance or raBalSnapOk) and raRsiOk and raStructSnapOk and adxRAOk

// 5) Actual strategy enter condition (must match the script)
raExecEnter = (not inPos) and (mode == Mode.RangeA) and raEntryOk

if barstate.isconfirmed
    // World + key milestones
    if raWorld
        c_raContext += 1
    if (not inPos) and raDiscNow
        c_raDiscNow += 1
    if raMil_discRecent
        c_raDiscRecent += 1
    if raMil_snapReady
        c_raSnapReady += 1

    if raBlock_notBalance
        c_raBlock_notBalance += 1
    if raBlock_notDiscRecent
        c_raBlock_notDiscRecent += 1
    if raBlock_notReclaim
        c_raBlock_notReclaim += 1

    if raDecision
        c_raReclaimOk += 1  // reusing this counter as "decision events" is fine OR rename it

    // Actual enters
    if raExecEnter
        c_raEntryOk += 1

    // Veto reasons ONLY at decision point
    if raVeto_htfOn
        c_raBlock_htfOn += 1
    //if raVeto_bearActive
    //    c_raBlock_bearActive += 1
    if raVeto_bearLockout
        c_raBlock_bearLockout += 1
    if raVeto_rsi
        c_raBlock_rsi += 1
    if raVeto_struct
        c_raBlock_struct += 1
    if raVeto_adx
        c_raBlock_adx += 1
    if raVeto_farFromLow
        c_raBlock_farFromLow += 1
    if raVeto_belowMid
        c_raBlock_belowMid += 1
    if raVeto_risk
        c_raBlock_risk += 1
    if raVeto_rr
        c_raBlock_rr += 1
    if raVeto_rsiOnly
        c_raBlock_rsiOnly += 1
    if raVeto_adxOnly
        c_raBlock_adxOnly += 1
    if raVeto_rsiAndAdx
        c_raBlock_rsiAndAdx += 1
    if raVeto_bearAccepted
        c_raBlock_bearAcc += 1
    if raVeto_bearPending
        c_raBlock_bearPend += 1


var int entryScore = na

if entered
    if entryMode == Mode.Bull
        entryScore := scoreBull()
    else if entryMode == Mode.RangeA
        entryScore := scoreRA()
    else
        entryScore := na

//====================================================
// Outcome logging (arrays + table)
//====================================================
var array<string> logMode   = array.new_string()
var array<int>    logScore  = array.new_int()
var array<string> logExit   = array.new_string()
var array<int>    logOut    = array.new_int()

logTrade(_mode, _score, _exitReason, _outcome) =>
    array.push(logMode, _mode)
    array.push(logScore, _score)
    array.push(logExit, _exitReason)
    array.push(logOut, _outcome)
    // keep last 20
    if array.size(logMode) > 20
        array.shift(logMode), array.shift(logScore), array.shift(logExit), array.shift(logOut)


//====================================================
// Diagnostics HUD (bottom-right) — clean, readable numbers
//====================================================
var table hud = table.new(position.bottom_right, 2, 24)
var int hudLastBar = na


doHUD = showDiagHUD and barstate.isconfirmed and (na(hudLastBar) or bar_index != hudLastBar)
if doHUD
    hudLastBar := bar_index
    table.clear(hud, 0, 0, 1, 23)

    // Title
    table.cell(hud, 0, 0, "ADX Split HUD", text_color=color.white, bgcolor=color.new(color.black, 0))
    table.cell(hud, 1, 0, "", text_color=color.white, bgcolor=color.new(color.black, 0))

    // Rows (COMPACT)

    // --- BULL (signal -> entry pressure) ---
    table.cell(hud, 0, 1, "Bull reclaim signals", text_color=color.black)
    table.cell(hud, 1, 1, str.tostring(c_reclaim), text_color=color.black)

    table.cell(hud, 0, 2, "Blocked by Exec ADX", text_color=color.black)
    table.cell(hud, 1, 2, str.tostring(c_blockedExecADX), text_color=color.black)

    table.cell(hud, 0, 3, "Blocked by Regime ADX", text_color=color.black)
    table.cell(hud, 1, 3, str.tostring(c_blockedRegimeADX), text_color=color.black)

    table.cell(hud, 0, 4, "Bull START signals", text_color=color.black)
    table.cell(hud, 1, 4, str.tostring(c_bullStartFinal), text_color=color.black)

    table.cell(hud, 0, 5, "START gate: window", text_color=color.black)
    table.cell(hud, 1, 5, str.tostring(c_bullStartWin), text_color=color.black)

    table.cell(hud, 0, 6, "START gate: strong", text_color=color.black)
    table.cell(hud, 1, 6, str.tostring(c_bullStartStrong), text_color=color.black)

    table.cell(hud, 0, 7, "START gate: not ext", text_color=color.black)
    table.cell(hud, 1, 7, str.tostring(c_bullStartExt), text_color=color.black)

    table.cell(hud, 0, 8, "START gate: ADX ok", text_color=color.black)
    table.cell(hud, 1, 8, str.tostring(c_bullStartADX), text_color=color.black)

    table.cell(hud, 0, 9, "START gate: no-chase", text_color=color.black)
    table.cell(hud, 1, 9, str.tostring(c_bullStartNoChase), text_color=color.black)

    table.cell(hud, 0, 10, "START gate: microPB", text_color=color.black)
    table.cell(hud, 1, 10, str.tostring(c_bullStartMicroPB), text_color=color.black)

    table.cell(hud, 0, 11, "Bull COMP signals", text_color=color.black)
    table.cell(hud, 1, 11, str.tostring(c_bullCompSig), text_color=color.black)

    table.cell(hud, 0, 12, "Bull trail EXIT count", text_color=color.black)
    table.cell(hud, 1, 12, str.tostring(c_bullTrailExit), text_color=color.black)

    // --- ADD (pyramiding actually working?) ---
    table.cell(hud, 0, 13, "ADD PB / Reclaim / Enter", text_color=color.black)
    table.cell(hud, 1, 13, str.tostring(c_addPB) + " / " + str.tostring(c_addReclaim) + " / " + str.tostring(c_addSig), text_color=color.black)

    table.cell(hud, 0, 14, "ADD blocks TP1/ADX/SLOPE/EXT/SPC", text_color=color.black)
    table.cell(hud, 1, 14,
        str.tostring(c_addBlkTP1) + " / " +
        str.tostring(c_addBlkADX) + " / " +
        str.tostring(c_addBlkSlope) + " / " +
        str.tostring(c_addBlkExt) + " / " +
        str.tostring(c_addBlkSpc),
        text_color=color.black)

    table.cell(hud, 0, 15, "ADD blocks NH/HTF/Slow/Trail", text_color=color.black)
    table.cell(hud, 1, 15,
        str.tostring(c_addBlkNH) + " / " +
        str.tostring(c_addBlkHTF) + " / " +
        str.tostring(c_addBlkSlow) + " / " +
        str.tostring(c_addBlkTrail),
        text_color=color.black)

    table.cell(hud, 0, 16, "ADD fills / TP1 hits", text_color=color.black)
    table.cell(hud, 1, 16, str.tostring(c_addFill) + " / " + str.tostring(c_tp1Hits), text_color=color.black)


    // --- RANGE-A (conversion bottleneck only) ---
    table.cell(hud, 0, 17, "RA decision events", text_color=color.black)
    table.cell(hud, 1, 17, str.tostring(c_raReclaimOk), text_color=color.black)

    table.cell(hud, 0, 18, "RA entry OK", text_color=color.black)
    table.cell(hud, 1, 18, str.tostring(c_raEntryOk), text_color=color.black)

    table.cell(hud, 0, 19, "RA blocks: not reclaim", text_color=color.black)
    table.cell(hud, 1, 19, str.tostring(c_raBlock_notReclaim), text_color=color.black)

    table.cell(hud, 0, 20, "RA blocks: HTF/Bear/Lock", text_color=color.black)
    table.cell(hud, 1, 20,
        str.tostring(c_raBlock_htfOn) + " / " +
        str.tostring(c_raBlock_bearAcc) + " / " +
        str.tostring(c_raBlock_bearLockout),
        text_color=color.black)

    // --- BEAR SHORT (main trade engine now) ---
    table.cell(hud, 0, 21, "BEAR PB seen", text_color=color.black)
    table.cell(hud, 1, 21, str.tostring(c_bearPBSeen), text_color=color.black)

    table.cell(hud, 0, 22, "BEAR breakdown signals", text_color=color.black)
    table.cell(hud, 1, 22, str.tostring(c_bearBreakSig), text_color=color.black)

    table.cell(hud, 0, 23, "BEAR reentry OK bars", text_color=color.black)
    table.cell(hud, 1, 23, str.tostring(c_bearReentryOk), text_color=color.black)


//====================================================
// Exit execution (priority: Bear kill > Bull invalid > Stops > TPs > Time-stops)
//====================================================
var bool xBear = false
var bool xBullInv = false
var bool xRaStop = false
var bool xBullTp = false
var bool xRaTp = false
var bool xBullTs = false
var bool xRaTs = false

// Reset exit markers each bar (otherwise they stick forever)
xBear    := false
xBullInv := false
xRaStop  := false
xBullTp  := false
xRaTp    := false
xBullTs  := false
xRaTs    := false


if exitOk and inPos

    // 0) HTF flip kill-switch (SHORTS) — do not hold shorts into HTF bull
    shortHTFKill = inPos and isShort and htfTrendOk and (not htfNeutral)

    if shortHTFKill and ((posTag == "BEAR") or (posTag == "RANGEB"))
        //strategy.close("SHORT", comment="HTF-BULL-KILL")
        //strategy.close("RB_SHORT", comment="HTF-BULL-KILL")
        // --- Bear: pre-HTF kill exit on LTF reclaim (close-based) ---
        if barstate.isconfirmed
            if isShort and (logModeNow() == "BEAR") and bearExitUseReclaim
                bool reclaimLvlHit = (not na(bearReclLvl)) and (close > bearReclLvl)
                bool emaReclaimHit = bearExitUseEmaReclaim and (close > emaFast)
                bool reclaimNow = reclaimLvlHit or emaReclaimHit

                bearReclaimCloseCnt := reclaimNow ? (nz(bearReclaimCloseCnt[1]) + 1) : 0

                if bearReclaimCloseCnt >= bearExitReclaimBars
                    strategy.close("SHORT", comment="BEAR_RECLAIM_EXIT")
                    lastBearShortExitBar := bar_index
            else
                bearReclaimCloseCnt := 0

        closeShortAll("HTF-BULL-KILL")
        // temp tuple unpack
        [tmpExitPending, tmpExitReason, tmpExitOutcome, tmpRegExit] = L1_markExit("HTF-BULL-KILL", 0, logModeNow())

        // commit to globals
        L1_exitPending := tmpExitPending
        L1_exitReason  := tmpExitReason
        L1_exitOutcome := tmpExitOutcome
        L1_regExit     := tmpRegExit

        logTrade(logModeNow(), entryScore, "HTF-BULL-KILL", 0)


        lastBearShortExitBar := bar_index  // helps throttle BEAR re-entry after forced kill
        lastRBShortExitBar := bar_index
        pendingReset := true
        forcedMode := Mode.Wait
        forcedUntilBar := bar_index + downgradeBars

    // 1) Bear kill-switch (LONGS only)
    if bearExitNow and (posTag != "BEAR")
        xBear := true
        if posTag == "BULL" and not na(bullLevel)
            bullEndBar := bar_index
            bullEndY   := high + lblPadUp

        //strategy.close("LONG", comment="BEAR-EXIT")
        //strategy.close("LONG_ADD", comment="BEAR-EXIT")
        closeLongAll("BEAR-EXIT")
        // temp tuple unpack
        [tmpExitPending, tmpExitReason, tmpExitOutcome, tmpRegExit] = L1_markExit("BEAR-EXIT", 0, logModeNow())

        // commit to globals
        L1_exitPending := tmpExitPending
        L1_exitReason  := tmpExitReason
        L1_exitOutcome := tmpExitOutcome
        L1_regExit     := tmpRegExit

        // Outcome: 0 (emergency)
        logTrade(logModeNow(), entryScore, "BEAR-EXIT", 0)
        
       // --- RESET AFTER FLAT ---
        pendingReset := true

        // Downgrade Bear->RangeB after bear exit (flat override)
        forcedMode := Mode.RangeB
        forcedUntilBar := bar_index + downgradeBars

    // 1.1) Bear SHORT invalidation
    else if bearShortInvalid
        strategy.close("SHORT", comment="BEAR-INVALID")
        // temp tuple unpack
        [tmpExitPending, tmpExitReason, tmpExitOutcome, tmpRegExit] = L1_markExit("BEAR-INVALID", 0, logModeNow())

        // commit to globals
        L1_exitPending := tmpExitPending
        L1_exitReason  := tmpExitReason
        L1_exitOutcome := tmpExitOutcome
        L1_regExit     := tmpRegExit

        logTrade(logModeNow(), entryScore, "BEAR-INVALID", 0)
        
        lastBearShortExitBar := bar_index
        pendingReset := true
        forcedMode := Mode.RangeB
        forcedUntilBar := bar_index + downgradeBars

    // 1.15) Bear SHORT forced expiry close (prevents months-long holds)
    else if bearForceCloseShort and (posTag == "BEAR") and isShort
        bearForceCloseShort := false
        strategy.close("SHORT", comment="BEAR-EXP")
        // temp tuple unpack
        [tmpExitPending, tmpExitReason, tmpExitOutcome, tmpRegExit] = L1_markExit("BEAR-EXP", 0, logModeNow())

        // commit to globals
        L1_exitPending := tmpExitPending
        L1_exitReason  := tmpExitReason
        L1_exitOutcome := tmpExitOutcome
        L1_regExit     := tmpRegExit

        logTrade(logModeNow(), entryScore, "BEAR-EXP", 0)
        
        pendingReset := true
        forcedMode := Mode.RangeB
        forcedUntilBar := bar_index + downgradeBars


    // 1.2) RB SHORT invalidation
    else if rbShortInvalid
        strategy.close("RB_SHORT", comment="RB-S-INVALID")
        // temp tuple unpack
        [tmpExitPending, tmpExitReason, tmpExitOutcome, tmpRegExit] = L1_markExit("RB-S-INVALID", 0, logModeNow())

        // commit to globals
        L1_exitPending := tmpExitPending
        L1_exitReason  := tmpExitReason
        L1_exitOutcome := tmpExitOutcome
        L1_regExit     := tmpRegExit

        logTrade(logModeNow(), entryScore, "RB-S-INVALID", 0)
        
        lastRBShortExitBar := bar_index
        pendingReset := true
        forcedMode := Mode.RangeB
        forcedUntilBar := bar_index + downgradeBars

    // 1.5) Bull TP1 (partial) — do NOT end trade
    //else if bullTP1Hit
    //    strategy.close("LONG", qty_percent=bullTP1_Pct, comment="BULL-TP1")
    //    bullTP1Done := true
    //    c_tp1Hits += 1

    // 2) Bull invalidation
    else if bullCloseInvalid and (not bullTP1Hit)
        xBullInv := true
        if bullPostTrailInvalid
            c_bullTrailExit += 1

        // ---- END BULL (in-position invalidation) ----
        if not na(bullLevel)
            bullEndBar := bar_index
            bullEndY   := high + lblPadUp
        
        //strategy.close("LONG", comment="BULL-INVALID")
        //strategy.close("LONG_ADD", comment="BULL-INVALID")
        closeLongAll("BULL-INVALID")
        // temp tuple unpack
        [tmpExitPending, tmpExitReason, tmpExitOutcome, tmpRegExit] = L1_markExit("BULL-INVALID", 0, logModeNow())

        // commit to globals
        L1_exitPending := tmpExitPending
        L1_exitReason  := tmpExitReason
        L1_exitOutcome := tmpExitOutcome
        L1_regExit     := tmpRegExit

        logTrade(logModeNow(), entryScore, "BULL-INVALID", 0)
        
        // --- RESET AFTER FLAT ---
        pendingReset := true

        // Downgrade Bull->RangeB
        forcedMode := Mode.RangeB
        forcedUntilBar := bar_index + downgradeBars

    // 3) Range-A stop
    else if raStopHit
        xRaStop := true
        //strategy.close("LONG", comment="RA-STOP")
        //strategy.close("LONG_ADD", comment="RA-STOP")  // same comment for that block
        closeLongAll("RA-STOP")    
    // temp tuple unpack
        [tmpExitPending, tmpExitReason, tmpExitOutcome, tmpRegExit] = L1_markExit("RA-STOP", 0, logModeNow())

        // commit to globals
        L1_exitPending := tmpExitPending
        L1_exitReason  := tmpExitReason
        L1_exitOutcome := tmpExitOutcome
        L1_regExit     := tmpRegExit

        logTrade(logModeNow(), entryScore, "RA-STOP", 0)
        
        // --- RESET AFTER FLAT ---
        pendingReset := true

        // Downgrade RangeA->WAIT
        forcedMode := Mode.Wait
        forcedUntilBar := bar_index + downgradeBars


    // 5) RA TP
    else if raTPHit
        xRaTp := true
        //strategy.close("LONG", comment="RA-TP")
        //strategy.close("LONG_ADD", comment="RA-TP")
        closeLongAll("RA-TP")
        // temp tuple unpack
        [tmpExitPending, tmpExitReason, tmpExitOutcome, tmpRegExit] = L1_markExit("RA-TP", 0, logModeNow())

        // commit to globals
        L1_exitPending := tmpExitPending
        L1_exitReason  := tmpExitReason
        L1_exitOutcome := tmpExitOutcome
        L1_regExit     := tmpRegExit

        logTrade(logModeNow(), entryScore, "RA-TP", 1)
        
        // --- RESET AFTER FLAT ---
        pendingReset := true
        forcedUntilBar := na

    // 5.8) Bear SHORT time-stop
    else if bearTimeStop
        strategy.close("SHORT", comment="BEAR-TS")
        // temp tuple unpack
        [tmpExitPending, tmpExitReason, tmpExitOutcome, tmpRegExit] = L1_markExit("BEAR-TS", 0, logModeNow())

        // commit to globals
        L1_exitPending := tmpExitPending
        L1_exitReason  := tmpExitReason
        L1_exitOutcome := tmpExitOutcome
        L1_regExit     := tmpRegExit

        logTrade(logModeNow(), entryScore, "BEAR-TS", 0)
        
        lastBearShortExitBar := bar_index
        pendingReset := true
        forcedMode := Mode.RangeB
        forcedUntilBar := bar_index + downgradeBars

    // 5.9) RB SHORT time-stop
    else if rbShortTimeStop
        strategy.close("RB_SHORT", comment="RB-S-TS")
        // temp tuple unpack
        [tmpExitPending, tmpExitReason, tmpExitOutcome, tmpRegExit] = L1_markExit("RB-S-TS", 0, logModeNow())

        // commit to globals
        L1_exitPending := tmpExitPending
        L1_exitReason  := tmpExitReason
        L1_exitOutcome := tmpExitOutcome
        L1_regExit     := tmpRegExit

        logTrade(logModeNow(), entryScore, "RB-S-TS", 0)
       
        lastRBShortExitBar := bar_index
        pendingReset := true
        forcedMode := Mode.RangeB
        forcedUntilBar := bar_index + downgradeBars


    // 6) Bull time-stop
    else if bullTimeStop
        xBullTs := true
        if not na(bullLevel)
            bullEndBar := bar_index
            bullEndY   := high + lblPadUp

        //strategy.close("LONG", comment="BULL-TS")
        //strategy.close("LONG_ADD", comment="BULL-TS")
        closeLongAll("BULL-TS")
        // temp tuple unpack
        [tmpExitPending, tmpExitReason, tmpExitOutcome, tmpRegExit] = L1_markExit("BULL-TS", 0, logModeNow())

        // commit to globals
        L1_exitPending := tmpExitPending
        L1_exitReason  := tmpExitReason
        L1_exitOutcome := tmpExitOutcome
        L1_regExit     := tmpRegExit

        logTrade(logModeNow(), entryScore, "BULL-TS", 0)
       
        // --- RESET AFTER FLAT ---
        pendingReset := true
        // Downgrade Bull->RangeB
        forcedMode := Mode.RangeB
        forcedUntilBar := bar_index + downgradeBars

    // 7) RA time-stop
    else if raTimeStop
        xRaTs := true
        //strategy.close("LONG", comment="RA-TS")
        //strategy.close("LONG_ADD", comment="RA-TS")
        closeLongAll("RA-TS")
        // temp tuple unpack
        [tmpExitPending, tmpExitReason, tmpExitOutcome, tmpRegExit] = L1_markExit("RA-TS", 0, logModeNow())

        // commit to globals
        L1_exitPending := tmpExitPending
        L1_exitReason  := tmpExitReason
        L1_exitOutcome := tmpExitOutcome
        L1_regExit     := tmpRegExit

        logTrade(logModeNow(), entryScore, "RA-TS", 0)
       
        // --- RESET AFTER FLAT ---
        pendingReset := true
        // Downgrade RangeA->WAIT
        forcedMode := Mode.Wait
        forcedUntilBar := bar_index + downgradeBars

// Flat RB time-stop (transitional regime must resolve)
if rbFlatTimeStop
        // Strategy v1.0 compliance: RB is a no-trade regime manager.
    // If RB fails to resolve within rbTS_Bars, log it as a regime failure (outcome=0).
    logTrade("RANGE-B", scoreRB(), "RB-TS", 0)

    // RB -> RangeA downgrade
    rbAttempt := false
    rbAttemptDir := 0
    rbAttemptBar := na
    rbAttOldLow := na
    rbAttOldHigh := na
    rbAttOldMid := na

    rbPending := false
    rbActive := false
    rbDir := 0
    rbStartBar := na
    rbOldLow := na
    rbOldHigh := na
    rbOldMid := na
    rbNewLow := na
    rbNewHigh := na
    rbNewMid := na
    bool raForcedOk = htfOffForRA and (raInBalance or raBalSnapOk) and raDiscRecent and (not bearActive) and bearLockoutOk
    forcedMode := raForcedOk ? Mode.RangeA : Mode.Wait
    forcedUntilBar := bar_index + downgradeBars



// RB resolution transitions
if rbActive
    // Reversion back into old range => Range-A
    if rbRevertAccept
        rbActive := false
        rbDir := 0
        rbStartBar := na
        // drop into Range-A mode naturally; no forced override
    // Acceptance upward => Bull
    else if rbBullAccept
        rbActive := false
        rbDir := 0
        rbStartBar := na
    // Acceptance down => Bear
    else if rbBearAccept
        rbActive := false
        rbDir := 0
        rbStartBar := na
        // Bear will arm/activate via bear logic on HTF OFF + acceptance; no manual flip here.

//====================================================
// Visuals — RAW regime states (trade-origin aware)
//====================================================

// Bear is always an overlay (pending/active), even during trades.
bearVis = (pendingBear or bearActive)

// Trade-origin regime shading while in position
originBull = inPos and (posTag == "BULL")
originRA   = inPos and (posTag == "RANGEA")
originRB   = inPos and (posTag == "RANGEB")

// Range-B should be visible while flat if RB is in attempt/pending/active.
// While in position, only show RB if the position ORIGIN is RANGEB.
rbVis = (not inPos) ? (rbAttempt or rbPending or rbActive) : originRB

// Range-A visible while flat if RA conditions exist.
// While in position, only show RA if the position ORIGIN is RANGEA.
raVis = (not inPos) ? ((not htfTrendOk) and raInBalance and (not bearActive)) : originRA

// Bull visible while flat if bull setup truth exists and HTF allows Bull mode.
// While in position, only show Bull if the position ORIGIN is BULL.
bullTruthLive = (pendingBull or bullArmed or bullPBSeen)
bullVis = (not inPos) ? (bullTruthLive and htfTrendOk) : originBull


// Router-selected mode state (what you currently show)
bearModeVis = bearVis  // overlay always wins visually
bullModeVis = (mode == Mode.Bull)
raModeVis   = (mode == Mode.RangeA)
rbModeVis   = (mode == Mode.RangeB)

// Choose which source drives shading
useBear = regimeUseRaw ? bearVis : bearModeVis
useRB   = regimeUseRaw ? rbVis   : rbModeVis
useRA   = regimeUseRaw ? raVis   : raModeVis
useBull = regimeUseRaw ? bullVis : bullModeVis

// Color priority: Bear > RB > RA > Bull > none
color regimeBg = na
if useBear
    regimeBg := color.new(color.red, regimeBgAlpha)
else if useRB
    regimeBg := color.new(color.orange, regimeBgAlpha)
else if useRA
    regimeBg := color.new(color.gray, regimeBgAlpha)
else if useBull
    regimeBg := color.new(color.green, regimeBgAlpha)
else
    regimeBg := na

// If you want to keep your old showModeBg toggle, repurpose it:
bgcolor(showRegimeBg ? regimeBg : na)



// ===== CHUNK 2 END =====


// ===== CHUNK 3 START =====
//====================================================
// Regime flip labels (START / END)
//====================================================

// Use the same booleans you used for background shading.
// If you implemented the shading patch I gave earlier, these exist:
// useBear, useRB, useRA, useBull
// If not, define them here based on router mode:
// useBear := (pendingBear or bearActive)
// useRB   := (rbAttempt or rbPending or rbActive)
// useRA   := (mode == Mode.RangeA)
// useBull := (mode == Mode.Bull)

// ---- LABEL TRUTH (flat-only, not visual shading) ----
lblBear = (not inPos) and (pendingBear or bearActive)
lblRB   = (not inPos) and (rbAttempt or rbPending or rbActive)
lblRA   = (not inPos) and (mode == Mode.RangeA)
lblBull = (not inPos) and (mode == Mode.Bull)

// Exclusive regime id with priority: Bear > RB > RA > Bull > WAIT
regimeId =
     lblBear ? 4 :
     lblRB   ? 3 :
     lblRA   ? 2 :
     lblBull ? 1 : 0


regimeName =
     regimeId == 4 ? "BEAR" :
     regimeId == 3 ? "RANGE-B" :
     regimeId == 2 ? "RANGE-A" :
     regimeId == 1 ? "BULL" : "WAIT"

// Detect flips
// Flip candidate
regimeFlipRaw = (regimeId != regimeId[1])

// --- SAFETY: precompute history-dependent functions every bar (no warnings, consistent) ---
barsSinceFlipRaw = ta.barssince(regimeFlipRaw)

// 1 if current regime has persisted for the full lookback window, else 0
regimeStableFlag = (regimeId == regimeId[1]) ? 1 : 0
regimeStableMin  = ta.lowest(regimeStableFlag, regimeMinBars)

// Confirm flip only if the new regime persists for regimeMinBars bars
regimeFlip = regimeFlipRaw and (barsSinceFlipRaw == 0) and (regimeStableMin == 1)

// Label gating (prevents spam on realtime partial bars)
doRegimeLabels = showRegimeFlipLabels and (not inPos) and (not regimeLabelOnlyOnClose or barstate.isconfirmed)
doAnchoredLabels = showRegimeFlipLabels and (not regimeLabelOnlyOnClose or barstate.isconfirmed)

// -------------------------
// BEAR labels (STRUCTURE-ANCHORED)
// -------------------------
bearStartNow = doAnchoredLabels and not na(bearStartBar) and (bar_index == bearStartBar)
bearEndNow   = doAnchoredLabels and not na(bearEndBar)   and (bar_index == bearEndBar)

if bearStartNow
    label.new(
        bar_index, bearStartY,
        text="START BEAR",
        style=label.style_label_down,
        textcolor=color.white,
        color=color.new(color.black, 0),
        size=size.small
    )

if bearEndNow
    label.new(
        bar_index, bearEndY,
        text="END BEAR",
        style=label.style_label_up,
        textcolor=color.white,
        color=color.new(color.black, 0),
        size=size.small
    )

// -------------------------
// BULL labels (STRUCTURE-ANCHORED)
// -------------------------
bullStartNow = doAnchoredLabels and (not useBear) and not na(bullStartBar) and (bar_index == bullStartBar)
bullEndNow   = doAnchoredLabels and (not useBear) and not na(bullEndBar)   and (bar_index == bullEndBar)

if bullStartNow
    label.new(
        bar_index, bullStartY,
        text="START BULL",
        style=label.style_label_up,
        textcolor=color.white,
        color=color.new(color.black, 0),
        size=size.small
    )

if bullEndNow
    label.new(
        bar_index, bullEndY,
        text="END BULL",
        style=label.style_label_down,
        textcolor=color.white,
        color=color.new(color.black, 0),
        size=size.small
    )



if doRegimeLabels and regimeFlip
    // END label for previous regime (skip if previous was WAIT)
    if regimeId[1] != 0 and regimeId[1] != 4 and regimeId[1] != 1
        label.new(
            bar_index, high,
            text = "END " + (regimeId[1] == 4 ? "BEAR" :
                             regimeId[1] == 3 ? "RANGE-B" :
                             regimeId[1] == 2 ? "RANGE-A" :
                             regimeId[1] == 1 ? "BULL" : "WAIT"),
            style = label.style_label_down,
            textcolor = color.white,
            color = color.new(color.black, 0),
            size = size.small
        )

    // START label for new regime (skip if new is WAIT)
    if regimeId != 0 and regimeId != 4 and regimeId != 1
        label.new(
            bar_index, low,
            text = "START " + regimeName,
            style = label.style_label_up,
            textcolor = color.white,
            color = color.new(color.black, 0),
            size = size.small
        )


//====================================================
// Mode label (last bar only) — observability
//====================================================
var label modeLbl = na
var int modeLblLastBar = na


doModeLbl = showModeLabel and barstate.isconfirmed and (na(modeLblLastBar) or bar_index != modeLblLastBar)
if doModeLbl
    modeLblLastBar := bar_index
    if na(modeLbl)
        modeLbl := label.new(bar_index, high, modeToStr(mode), style=label.style_label_down, textcolor=color.white, color=color.new(color.black, 0))
    else
        label.set_x(modeLbl, bar_index)
        label.set_y(modeLbl, high)
        label.set_text(modeLbl, modeToStr(mode))


//====================================================
// L1 commit on actual position open (fill)
//====================================================
if exportToLogs and barstate.isconfirmed and posOpened
    L1_tradeId += 1

    L1_coin     := syminfo.ticker
    L1_dir      := L1_pendDir
    L1_regEntry := L1_pendReg
    L1_arch     := L1_pendArch

    L1_entryTime := time
    L1_entryPx   := close
    L1_entrySize := strategy.position_size
    L1_entryEq   := strategy.equity
    L1_entryNP   := strategy.netprofit
    L1_entryBar  := bar_index

    // init max favorable / adverse
    if strategy.position_size > 0
        L1_maxFavPx  := high
        L1_maxFavBar := bar_index
        L1_maxAdvPx  := low
        L1_maxAdvBar := bar_index
    else
        // short: favorable is lower low, adverse is higher high
        L1_maxFavPx  := low
        L1_maxFavBar := bar_index
        L1_maxAdvPx  := high
        L1_maxAdvBar := bar_index

    // clear pending entry latch (so it can't leak)
    L1_pendDir  := ""
    L1_pendReg  := ""
    L1_pendArch := ""


plotshape(showExecMarks and posOpened, title="EXEC OPEN", text="OPEN", style=shape.labelup,
     location=location.belowbar, size=size.tiny, color=color.new(color.lime, 0), textcolor=color.black)

plotshape(showExecMarks and posClosed, title="EXEC CLOSE", text="CLOSE", style=shape.labeldown,
     location=location.abovebar, size=size.tiny, color=color.new(color.red, 0), textcolor=color.white)



    // Reset exit latch
    //L1_exitPending := false
    //L1_exitReason  := ""
    //L1_exitOutcome := na
    //L1_regExit     := ""

//plotshape(showExecMarks and xBear,    title="X BEAR",    text="X-BEAR", style=shape.labeldown, location=location.abovebar, size=size.tiny)
//plotshape(showExecMarks and xBullInv, title="X B-INV",   text="X-BINV", style=shape.labeldown, location=location.abovebar, size=size.tiny)
//plotshape(showExecMarks and xRaStop,  title="X RA-STOP", text="X-RAST", style=shape.labeldown, location=location.abovebar, size=size.tiny)
//plotshape(showExecMarks and xBullTp,  title="X B-TP",    text="X-BTP",  style=shape.labeldown, location=location.abovebar, size=size.tiny)
//plotshape(showExecMarks and xRaTp,    title="X RA-TP",   text="X-RATP", style=shape.labeldown, location=location.abovebar, size=size.tiny)
//plotshape(showExecMarks and xBullTs,  title="X B-TS",    text="X-BTS",  style=shape.labeldown, location=location.abovebar, size=size.tiny)
//plotshape(showExecMarks and xRaTs,    title="X RA-TS",   text="X-RATS", style=shape.labeldown, location=location.abovebar, size=size.tiny)

//plotshape(showExecMarks and bullEnter,   title="SIG BullEnter",   text="B",  style=shape.circle, location=location.belowbar, size=size.tiny)
//plotshape(showExecMarks and rangeAEnter, title="SIG RangeAEnter", text="RA", style=shape.circle, location=location.belowbar, size=size.tiny)

//plotshape(showRegimeMarks and (not inPos) and htfTrendOk and (pendingBull or bullArmed) and (not bullPBSeen), title="BULL attempt", text="BULL-ATT", style=shape.labelup, location=location.bottom, size=size.tiny)


//plotchar(showDebugPlots ? raDiscNow   : false, title="DBG RA disc",    char="D", location=location.bottom)
//plotchar(showDebugPlots ? raReclaimOk : false, title="DBG RA reclaim", char="R", location=location.bottom)
//plotchar(showDebugPlots ? rbPending   : false, title="DBG RB pending", char="p", location=location.bottom)
//plotchar(showDebugPlots ? rbActive    : false, title="DBG RB active",  char="B", location=location.bottom)
//plotchar(showDebugPlots ? pendingBear : false, title="DBG BearPending", char="x", location=location.bottom)
//plotchar(showDebugPlots ? bearActive  : false, title="DBG BearActive",  char="X", location=location.bottom)
//plotchar(showDebugPlots ? bullArmed   : false, title="DBG BullArmed",  char="A", location=location.bottom)
//plotchar(showDebugPlots ? bullPBSeen  : false, title="DBG BullPB",     char="P", location=location.bottom)

//====================================================
// Trade log table (last ~10 rows)
//====================================================
var table t = table.new(position.top_right, 4, 12)
var int logLastBar = na


bool doTableUpdate = showLogTable and barstate.isconfirmed and (na(logLastBar) or bar_index != logLastBar)
if doTableUpdate
    logLastBar := bar_index
    table.clear(t, start_column=0, start_row=0, end_column=3, end_row=11)
    table.cell(t, 0, 0, "Mode",  text_color=color.white, bgcolor=color.new(color.black, 0))
    table.cell(t, 1, 0, "Score", text_color=color.white, bgcolor=color.new(color.black, 0))
    table.cell(t, 2, 0, "Exit",  text_color=color.white, bgcolor=color.new(color.black, 0))
    table.cell(t, 3, 0, "Out",   text_color=color.white, bgcolor=color.new(color.black, 0))

    int n = array.size(logMode)

    for r = 0 to 9
        int idx = n - 1 - r
        if idx >= 0
            table.cell(t, 0, r+1, array.get(logMode, idx))
            table.cell(t, 1, r+1, str.tostring(array.get(logScore, idx)))
            table.cell(t, 2, r+1, array.get(logExit, idx))
            table.cell(t, 3, r+1, str.tostring(array.get(logOut, idx)))
        else
            table.cell(t, 0, r+1, "")
            table.cell(t, 1, r+1, "")
            table.cell(t, 2, r+1, "")
            table.cell(t, 3, r+1, "")
